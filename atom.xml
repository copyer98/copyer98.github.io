<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://copyer98.github.io</id>
    <title>Gridea</title>
    <updated>2022-03-05T16:46:44.477Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://copyer98.github.io"/>
    <link rel="self" href="https://copyer98.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://copyer98.github.io/images/avatar.png</logo>
    <icon>https://copyer98.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, Gridea</rights>
    <entry>
        <title type="html"><![CDATA[java教程]]></title>
        <id>https://copyer98.github.io/post/java教程/</id>
        <link href="https://copyer98.github.io/post/java教程/">
        </link>
        <updated>2021-10-14T01:17:00.000Z</updated>
        <content type="html"><![CDATA[<h1 id="java教程">java教程</h1>
<p>标签： 干货</p>
<p><a href="https://snailclimb.gitee.io/springboot-guide/#/">springboot学习指南</a></p>
<p><a href="https://snailclimb.gitee.io/javaguide/#/">JavaGuide (gitee.io)</a></p>
<p><a href="https://java.quanke.name/">Introduction · Thinking in Java (Java 编程思想) (quanke.name)</a></p>
<p><a href="https://frank-lam.github.io/fullstack-tutorial/#/">fullstack tutorial - 全栈开发指南 (frank-lam.github.io)</a></p>
<p><a href="https://cyc2018.github.io/CS-Notes/#/">CS-Notes (cyc2018.github.io)</a></p>
<p><a href="http://hollischuang.gitee.io/tobetopjavaer/#/">Java工程师成神之路 (gitee.io)</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Vue-渐进式JavaScript框架]]></title>
        <id>https://copyer98.github.io/post/vue2教程/</id>
        <link href="https://copyer98.github.io/post/vue2教程/">
        </link>
        <updated>2021-06-29T01:17:00.000Z</updated>
        <summary type="html"><![CDATA[<p>正在更新中...</p>
<h1 id="vue-渐进式javascript框架">Vue -渐进式JavaScript框架</h1>
<h2 id="介绍">介绍</h2>
<ul>
<li><a href="https://cn.vuejs.org/">vue2官网</a> (<a href="https://v3.cn.vuejs.org/">vue3在这里</a>)</li>
<li><a href="https://router.vuejs.org/zh/">vue-rotuer官网</a></li>
<li><a href="https://vuex.vuejs.org/zh/">vuex官网</a></li>
<li><a href="https://devtools.vuejs.org/">vue调试工具(必装,需要科学上网)</a></li>
<li><a href="https://github.com/vuejs/awesome-vue">vue组件大全</a></li>
<li><a href="https://cli.vuejs.org/zh/">vue-cli开发工具</a></li>
<li><a href="https://cn.vitejs.dev/">vite开发工具</a></li>
<li><a href="https://ssr.vuejs.org/zh/">vue-ssr官网</a></li>
<li><a href="https://nuxtjs.org/">nuxtjs官网</a>(实现vuessr,快速搭建平台)</li>
<li>Vue.js 是一套构建用户界面(UI)的渐进式JavaScript框架</li>
</ul>
<h3 id="学习vue要转化思想">学习Vue要转化思想</h3>
<ul>
<li>不要在想着怎么操作DOM(jquery思想)，而是想着如何操作数据！！！</li>
</ul>
<h2 id="起步-hello-vue">起步 - Hello Vue</h2>
]]></summary>
        <content type="html"><![CDATA[<p>正在更新中...</p>
<h1 id="vue-渐进式javascript框架">Vue -渐进式JavaScript框架</h1>
<h2 id="介绍">介绍</h2>
<ul>
<li><a href="https://cn.vuejs.org/">vue2官网</a> (<a href="https://v3.cn.vuejs.org/">vue3在这里</a>)</li>
<li><a href="https://router.vuejs.org/zh/">vue-rotuer官网</a></li>
<li><a href="https://vuex.vuejs.org/zh/">vuex官网</a></li>
<li><a href="https://devtools.vuejs.org/">vue调试工具(必装,需要科学上网)</a></li>
<li><a href="https://github.com/vuejs/awesome-vue">vue组件大全</a></li>
<li><a href="https://cli.vuejs.org/zh/">vue-cli开发工具</a></li>
<li><a href="https://cn.vitejs.dev/">vite开发工具</a></li>
<li><a href="https://ssr.vuejs.org/zh/">vue-ssr官网</a></li>
<li><a href="https://nuxtjs.org/">nuxtjs官网</a>(实现vuessr,快速搭建平台)</li>
<li>Vue.js 是一套构建用户界面(UI)的渐进式JavaScript框架</li>
</ul>
<h3 id="学习vue要转化思想">学习Vue要转化思想</h3>
<ul>
<li>不要在想着怎么操作DOM(jquery思想)，而是想着如何操作数据！！！</li>
</ul>
<h2 id="起步-hello-vue">起步 - Hello Vue</h2>
<!--more-->
<h3 id="使用vue-cli工具">使用vue-cli工具</h3>
<ul>
<li>安装：<code>npm i -g @vue/cli</code></li>
</ul>
<blockquote>
<p>vue-cli是什么?<br>
Vue CLI 是一个基于 Vue.js 进行快速开发的完整系统，提供：</p>
</blockquote>
<ul>
<li>通过 @vue/cli 搭建交互式的项目脚手架。</li>
<li>通过 @vue/cli + @vue/cli-service-global 快速开始零配置原型开发。<br>
一个运行时依赖 (@vue/cli-service)，该依赖：<br>
可升级；<br>
基于 webpack 构建，并带有合理的默认配置；<br>
可以通过项目内的配置文件进行配置；<br>
可以通过插件进行扩展。<br>
一个丰富的官方插件集合，集成了前端生态中最好的工具。<br>
一套完全图形化的创建和管理 Vue.js 项目的用户界面。</li>
</ul>
<blockquote>
<p>如何使用?</p>
</blockquote>
<pre><code class="language-bash">//创建一个项目
vue create your-app
//之后按照提示来就可以

vue ui  //使用可视化界面配置项目
</code></pre>
<h3 id="使用vite开发">使用vite开发</h3>
<p><a href="https://github.com/vitejs/vite">Vite</a> 是一个 web 开发构建工具，由于其原生 ES 模块导入方式，可以实现闪电般的冷服务器启动。<br>
通过在终端中运行以下命令，可以使用 Vite 快速构建 Vue 项目。<br>
使用 npm：</p>
<pre><code class="language-bash">npm init @vitejs/app &lt;project-name&gt;
cd &lt;project-name&gt;
npm install
npm run dev
</code></pre>
<p>或者 yarn：</p>
<pre><code class="language-bash">yarn create @vitejs/app &lt;project-name&gt;
cd &lt;project-name&gt;
yarn
yarn dev
</code></pre>
<p>但是对于vue2需要一个插件,需要在根目录添加一个vite.config.js,并使用插件vite-plugin-vue2(需要自己研究配置)</p>
<pre><code class="language-bash">const { createVuePlugin } = require('vite-plugin-vue2');

module.exports = {
  plugins: [createVuePlugin()],
};
</code></pre>
<p>创建一个hellowold程序</p>
<pre><code class="language-html">
&lt;!-- 指定vue管理内容区域，需要通过vue展示的内容都要放到找个元素中  通常我们也把它叫做边界 数据只在边界内部解析--&gt;
&lt;div id=&quot;app&quot;&gt;{{ msg }}&lt;/div&gt;

&lt;!-- 引入 vue.js --&gt;
&lt;script src=&quot;vue.js&quot;&gt;&lt;/script&gt;

&lt;!-- 使用 vue --&gt;
&lt;script&gt;
  var vm = new Vue({
    // el：提供一个在页面上已存在的 DOM 元素作为 Vue 实例的挂载目标
    el: '#app',
    // Vue 实例的数据对象，用于给 View 提供数据
    data: {
      msg: 'Hello Vue'
    }
  })
&lt;/script&gt;
</code></pre>
<h3 id="vue实例">Vue实例</h3>
<ul>
<li>注意 1：<strong>先在data中声明数据，再使用数据</strong></li>
<li>注意 2：可以通过 <code>vm.$data</code> 访问到data中的所有属性，或者 <code>vm.msg</code></li>
</ul>
<pre><code>var vm = new Vue({
  data: {
    msg: '大家好，...'
  }
})

vm.$data.msg === vm.msg // true
</code></pre>
<h3 id="数据绑定">数据绑定</h3>
<ul>
<li>最常用的方式：<code>Mustache(插值语法)</code>，也就是 <code>{{}}</code> 语法</li>
<li>解释：<code>{{}}</code>从数据对象<code>data</code>中获取数据</li>
<li>说明：数据对象的属性值发生了改变，插值处的内容都会更新</li>
<li>说明：<code>{{}}</code>中只能出现JavaScript表达式 而不能解析js语句</li>
<li>注意：<strong>Mustache 语法不能作用在 HTML 元素的属性上</strong></li>
</ul>
<pre><code>&lt;h1&gt;Hello, {{ msg }}.&lt;/h1&gt;
&lt;p&gt;{{ 1 + 2 }}&lt;/p&gt;
&lt;p&gt;{{ isOk ? 'yes': 'no' }}&lt;/p&gt;

&lt;!-- ！！！错误示范！！！ --&gt;
&lt;h1 title=&quot;{{ err }}&quot;&gt;&lt;/h1&gt;
</code></pre>
<h2 id="双向数据绑定-vue-two-way-data-binding">双向数据绑定 Vue two way data binding</h2>
<ul>
<li>双向数据绑定：将DOM与Vue实例的data数据绑定到一起，彼此之间相互影响
<ul>
<li>数据的改变会引起DOM的改变</li>
<li>DOM的改变也会引起数据的变化</li>
</ul>
</li>
<li>原理：<code>Object.defineProperty</code>中的<code>get</code>和<code>set</code>方法
<ul>
<li><code>getter</code>和<code>setter</code>：访问器</li>
<li>作用：指定<code>读取或设置</code>对象属性值的时候，执行的操作</li>
</ul>
</li>
<li><a href="https://cn.vuejs.org/v2/guide/reactivity.html">Vue - 深入响应式原理</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty">MDN - Object.defineProperty()</a></li>
</ul>
<pre><code class="language-javascript">/*  defineProperty语法 介绍 */
var obj = {}
Object.defineProperty(obj, 'msg', {
  // 设置 obj.msg = &quot;1&quot; 时set方法会被系统调用 参数分别是设置后和设置前的值
  set: function (newVal, oldVal) {  },
  // 读取 obj.msg 时get方法会被系统调用
  get: function ( newVal, oldVal ) {}
})
</code></pre>
<h3 id="vue双向绑定的极简实现">Vue双向绑定的极简实现</h3>
<ul>
<li><a href="https://segmentfault.com/a/1190000006599500">剖析Vue原理&amp;实现双向绑定MVVM</a></li>
</ul>
<pre><code class="language-html">&lt;!-- 示例 --&gt;
&lt;input type=&quot;text&quot; id=&quot;txt&quot; /&gt;
&lt;span id=&quot;sp&quot;&gt;&lt;/span&gt;

&lt;script&gt;
var txt = document.getElementById('txt'),
    sp = document.getElementById('sp'),
    obj = {}

// 给对象obj添加msg属性，并设置setter访问器
Object.defineProperty(obj, 'msg', {
  // 设置 obj.msg  当obj.msg反生改变时set方法将会被调用  
  set: function (newVal) {
    // 当obj.msg被赋值时 同时设置给 input/span
    txt.value = newVal
    sp.innerText = newVal
  }
})

// 监听文本框的改变 当文本框输入内容时 改变obj.msg
txt.addEventListener('keyup', function (event) {
  obj.msg = event.target.value
})
&lt;/script&gt;
</code></pre>
<h3 id="动态添加数据的注意点">动态添加数据的注意点</h3>
<ul>
<li>注意：只有<code>data</code>中的数据才是响应式的，动态添加进来的数据默认为非响应式</li>
<li>可以通过以下方式实现动态添加数据的响应式
<ul>
<li>1 <code>Vue.set(object, key, value)</code> - 适用于添加单个属性</li>
<li>2 <code>Object.assign()</code> - 适用于添加多个属性</li>
</ul>
</li>
</ul>
<pre><code class="language-javascript">var vm = new Vue({
  data: {
    stu: {
      name: 'jack',
      age: 19
    }
  }
})

/* Vue.set */
Vue.set(vm.stu, 'gender', 'male')

/* Object.assign 将参数中的所有对象属性和值 合并到第一个参数 并返回合并后的对象*/
vm.stu = Object.assign({}, vm.stu, { gender: 'female', height: 180 })
</code></pre>
<h3 id="异步dom更新">异步DOM更新</h3>
<ul>
<li>说明：Vue 异步执行 DOM 更新，监视所有数据改变，一次性更新DOM</li>
<li>优势：可以去除重复数据，对于避免不必要的计算和 避免重复 DOM 操作上，非常重要</li>
<li>如果需要那到更新后dom中的数据 则需要通过 <code>Vue.nextTick(callback)</code>：在DOM更新后，执行某个操作（属于DOM操作）
<ul>
<li>实例调用<code>vm.$nextTick(function () {})</code></li>
</ul>
</li>
</ul>
<pre><code>methods: {
  fn() {
    this.msg = 'change'
    this.$nextTick(function () {
      console.log('$nextTick中打印：', this.$el.children[0].innerText);
    })
    console.log('直接打印：', this.$el.children[0].innerText);
  }
}
</code></pre>
<h2 id="指令">指令</h2>
<ul>
<li>解释：指令 (Directives) 是带有 <code>v-</code> 前缀的特殊属性</li>
<li>作用：当表达式的值改变时，将其产生的连带影响，响应式地作用于 DOM</li>
</ul>
<h3 id="v-text">v-text</h3>
<ul>
<li>解释：更新DOM对象的 textContent</li>
</ul>
<pre><code>&lt;h1 v-text=&quot;msg&quot;&gt;&lt;/h1&gt;
</code></pre>
<h3 id="v-html">v-html</h3>
<ul>
<li>解释：更新DOM对象的 innerHTML</li>
</ul>
<pre><code>&lt;h1 v-html=&quot;msg&quot;&gt;&lt;/h1&gt;
</code></pre>
<h3 id="v-bind">v-bind</h3>
<ul>
<li>作用：当表达式的值改变时，将其产生的连带影响，响应式地作用于 DOM</li>
<li>语法：<code>v-bind:title=&quot;msg&quot;</code></li>
<li>简写：<code>:title=&quot;msg&quot;</code></li>
</ul>
<pre><code>&lt;!-- 完整语法 --&gt;
&lt;a v-bind:href=&quot;url&quot;&gt;&lt;/a&gt;
&lt;!-- 缩写 --&gt;
&lt;a :href=&quot;url&quot;&gt;&lt;/a&gt;
</code></pre>
<h3 id="v-on">v-on</h3>
<ul>
<li>作用：绑定事件</li>
<li>语法：<code>v-on:click=&quot;say&quot;</code> or <code>v-on:click=&quot;say('参数', $event)&quot;</code></li>
<li>简写：<code>@click=&quot;say&quot;</code></li>
<li>说明：绑定的事件定义在<code>methods</code></li>
</ul>
<pre><code>&lt;!-- 完整语法 --&gt;
&lt;a v-on:click=&quot;doSomething&quot;&gt;&lt;/a&gt;
&lt;!-- 缩写 --&gt;
&lt;a @click=&quot;doSomething&quot;&gt;&lt;/a&gt;
</code></pre>
<h3 id="事件修饰符">事件修饰符</h3>
<ul>
<li><code>.stop</code> 阻止冒泡，调用 event.stopPropagation()</li>
<li><code>.prevent</code> 阻止默认行为，调用 event.preventDefault()</li>
<li><code>.capture</code> 添加事件侦听器时使用事件<code>捕获</code>模式</li>
<li><code>.self</code> 只当事件在该元素本身（比如不是子元素）触发时，才会触发事件</li>
<li><code>.once</code> 事件只触发一次</li>
</ul>
<h3 id="v-model">v-model</h3>
<ul>
<li>作用：在表单元素上创建双向数据绑定</li>
<li>说明：监听用户的输入事件以更新数据</li>
<li>案例：计算器</li>
</ul>
<pre><code>&lt;input type=&quot;text&quot; v-model=&quot;message&quot; placeholder=&quot;edit me&quot;&gt;
&lt;p&gt;Message is: {{ message }}&lt;/p&gt;
</code></pre>
<h3 id="v-for">v-for</h3>
<ul>
<li>作用：基于源数据多次渲染元素或模板块</li>
</ul>
<pre><code class="language-html">&lt;!-- 1 基础用法 --&gt;
&lt;div v-for=&quot;item in items&quot;&gt;
  {{ item.text }}
&lt;/div&gt;

&lt;!-- item 为当前项，index 为索引 --&gt;
&lt;p v-for=&quot;(item, index) in list&quot;&gt;{{item}} -- {{index}}&lt;/p&gt;
&lt;!-- item 为值，key 为键，index 为索引 --&gt;
&lt;p v-for=&quot;(item, key, index) in obj&quot;&gt;{{item}} -- {{key}}&lt;/p&gt;
&lt;p v-for=&quot;item in 10&quot;&gt;{{item}}&lt;/p&gt;
</code></pre>
<h3 id="key属性">key属性</h3>
<ul>
<li>推荐：使用 <code>v-for</code> 的时候提供 <code>key</code> 属性，以获得性能提升。</li>
<li>说明：使用 key，VUE会基于 key 的变化重新排列元素顺序，并且会移除 key 不存在的元素。</li>
<li><a href="https://cn.vuejs.org/v2/guide/list.html#key">vue key</a></li>
<li><a href="https://www.zhihu.com/question/61064119/answer/183717717">vue key属性的说明</a></li>
</ul>
<pre><code>&lt;div v-for=&quot;item in items&quot; :key=&quot;item.id&quot;&gt;
  &lt;!-- 内容 --&gt;
&lt;/div&gt;
</code></pre>
<h2 id="样式处理-class和style">样式处理 -class和style</h2>
<ul>
<li>使用方式：<code>v-bind:class=&quot;expression&quot;</code> or <code>:class=&quot;expression&quot;</code></li>
<li>表达式的类型：字符串、数组、对象（重点）</li>
<li>语法：</li>
</ul>
<pre><code class="language-html">&lt;!-- 1 --&gt;
&lt;div v-bind:class=&quot;{ active: true }&quot;&gt;&lt;/div&gt; ===&gt; 解析后
&lt;div class=&quot;active&quot;&gt;&lt;/div&gt;

&lt;!-- 2 --&gt;
&lt;div :class=&quot;['active', 'text-danger']&quot;&gt;&lt;/div&gt; ===&gt;解析后
&lt;div class=&quot;active text-danger&quot;&gt;&lt;/div&gt;

&lt;!-- 3 --&gt;
&lt;div v-bind:class=&quot;[{ active: true }, errorClass]&quot;&gt;&lt;/div&gt; ===&gt;解析后
&lt;div class=&quot;active text-danger&quot;&gt;&lt;/div&gt;


--- style ---
&lt;!-- 1 --&gt;
&lt;div v-bind:style=&quot;{ color: activeColor, 'font-size': fontSize + 'px' }&quot;&gt;&lt;/div&gt;
&lt;!-- 2 将多个 样式对象 应用到一个元素上--&gt;
&lt;!-- baseStyles 和 overridingStyles 都是data中定义的对象 --&gt;
&lt;div v-bind:style=&quot;[baseStyles, overridingStyles]&quot;&gt;&lt;/div&gt;
</code></pre>
<h3 id="v-if-和-v-show">v-if 和 v-show</h3>
<ul>
<li><a href="https://cn.vuejs.org/v2/guide/conditional.html">条件渲染</a></li>
<li><code>v-if</code>：根据表达式的值的真假条件，销毁或重建元素</li>
<li><code>v-show</code>：根据表达式之真假值，切换元素的 display CSS 属性</li>
</ul>
<pre><code>&lt;p v-show=&quot;isShow&quot;&gt;这个元素展示出来了吗？？？&lt;/p&gt;
&lt;p v-if=&quot;isShow&quot;&gt;这个元素，在HTML结构中吗？？？&lt;/p&gt;
</code></pre>
<h3 id="提升性能v-pre">提升性能：v-pre</h3>
<ul>
<li>说明：vue会跳过这个元素和它的子元素的编译过程。可以用来显示原始 Mustache 标签。跳过大量没有指令的节点会加快编译。</li>
</ul>
<pre><code>&lt;span v-pre&gt;{{ this will not be compiled }}&lt;/span&gt;
</code></pre>
<h3 id="提升性能v-once">提升性能：v-once</h3>
<ul>
<li>说明：vue只渲染元素和组件一次。随后的重新渲染，元素/组件及其所有的子节点将被视为静态内容并跳过。这可以用于优化更新性能。</li>
</ul>
<pre><code>&lt;span v-once&gt;This will never change: {{msg}}&lt;/span&gt;
</code></pre>
<h2 id="过滤器-filter不建议用可以用计算属性和函数方法替代">过滤器 filter(不建议用,可以用计算属性和函数方法替代)</h2>
<ul>
<li>作用：文本数据格式化</li>
<li>过滤器可以用在两个地方：<code>{{}}</code>和 v-bind 表达式</li>
<li>两种过滤器：1 全局过滤器 2 局部过滤器</li>
</ul>
<h3 id="全局过滤器">全局过滤器</h3>
<ul>
<li>说明：通过全局方式创建的过滤器，在任何一个vue实例中都可以使用</li>
<li>注意：使用全局过滤器的时候，需要先创建全局过滤器，再创建Vue实例</li>
<li>显示的内容由过滤器的返回值决定</li>
</ul>
<pre><code>Vue.filter('filterName', function (value) {
  // value 表示要过滤的内容
})
</code></pre>
<ul>
<li>示例：</li>
</ul>
<pre><code>&lt;div&gt;{{ dateStr | date }}&lt;/div&gt;
&lt;div&gt;{{ dateStr | date('YYYY-MM-DD hh:mm:ss') }}&lt;/div&gt;

&lt;script&gt;
  Vue.filter('date', function(value, format) {
    // value 要过滤的字符串内容，比如：dateStr
    // format 过滤器的参数，比如：'YYYY-MM-DD hh:mm:ss'
  })
&lt;/script&gt;
</code></pre>
<h3 id="局部过滤器">局部过滤器</h3>
<ul>
<li>说明：局部过滤器是在某一个vue实例的内容创建的，只在当前实例中起作用</li>
</ul>
<pre><code>{
  data: {},
  // 通过 filters 属性创建局部过滤器
  // 注意：此处为 filters
  filters: {
    filterName: function(value, format) {}
  }
}
</code></pre>
<h2 id="按键值修饰符">按键值修饰符</h2>
<ul>
<li>说明：在监听键盘事件时，Vue 允许为 <code>v-on</code> 在监听键盘事件时添加关键修饰符</li>
<li><a href="https://cn.vuejs.org/v2/guide/events.html#">键盘事件 - 键值修饰符</a></li>
<li>其他：修饰键（.ctrl等）、鼠标按键修饰符（.left等）</li>
</ul>
<pre><code>// 只有在 keyCode 是 13 时调用 vm.submit()
@keyup.13=&quot;submit&quot;
// 使用全局按键别名
@keyup.enter=&quot;add&quot;

---

// 通过全局 config.keyCodes 对象自定义键值修饰符别名
Vue.config.keyCodes.f2 = 113
// 使用自定义键值修饰符
@keyup.enter.f2=&quot;add&quot;
</code></pre>
<h2 id="监视数据变化-watch">监视数据变化 - watch</h2>
<ul>
<li>概述：<code>watch</code>是一个对象，键是需要观察的表达式，值是对应回调函数</li>
<li>作用：当表达式的值发生变化后，会调用对应的回调函数完成响应的监视操作</li>
<li><a href="https://cn.vuejs.org/v2/api/#vm-watch">VUE $watch</a></li>
</ul>
<pre><code>new Vue({
  data: { a: 1, b: { age: 10 } },
  watch: {
    a: function(val, oldVal) {
      // val 表示当前值
      // oldVal 表示旧值
      console.log('当前值为：' + val, '旧值为：' + oldVal)
    },

    // 监听对象属性的变化
    b: {
      handler: function (val, oldVal) { /* ... */ },
      // deep : true表示是否监听对象内部属性值的变化 
      deep: true
    },

    // 只监视user对象中age属性的变化
    'user.age': function (val, oldVal) {
    },
  }
})
</code></pre>
<h2 id="计算属性">计算属性</h2>
<ul>
<li>说明：计算属性是基于它们的依赖进行缓存的，只有在它的依赖发生改变时才会重新求值</li>
<li>注意：Mustache语法 中不要放入太多的逻辑，否则会让模板过重、难以理解和维护</li>
<li>注意：<strong>computed中的属性不能与data中的属性同名，否则会报错</strong></li>
<li><a href="http://www.cnblogs.com/kidney/p/7384835.html?utm_source=debugrun&amp;utm_medium=referral">Vue computed属性原理</a></li>
</ul>
<pre><code>var vm = new Vue({
  el: '#app',
  data: {
    firstname: 'jack',
    lastname: 'rose'
  },
  computed: {
    fullname() {
      return this.firstname + '.' + this.lastname
    }
  }
})
</code></pre>
<h2 id="实例生命周期">实例生命周期</h2>
<ul>
<li>所有的 Vue 组件都是 Vue 实例，并且接受相同的选项对象即可 (一些根实例特有的选项除外)。</li>
<li>实例生命周期也叫做：组件生命周期</li>
</ul>
<h3 id="生命周期介绍">生命周期介绍</h3>
<ul>
<li><a href="https://cn.vuejs.org/v2/api/#">vue生命周期钩子函数</a></li>
<li>简单说：<strong>一个组件从开始到最后消亡所经历的各种状态，就是一个组件的生命周期</strong></li>
</ul>
<p>生命周期钩子函数的定义：从组件被创建，到组件挂载到页面上运行，再到页面关闭组件被卸载，这三个阶段总是伴随着组件各种各样的事件，这些事件，统称为组件的生命周期函数！</p>
<ul>
<li>注意：Vue在执行过程中会自动调用<code>生命周期钩子函数</code>，我们只需要提供这些钩子函数即可</li>
<li>注意：钩子函数的名称都是Vue中规定好的！</li>
</ul>
<h3 id="钩子函数-beforecreate">钩子函数 - beforeCreate()</h3>
<ul>
<li>说明：在实例初始化之后，数据观测 (data observer) 和 event/watcher 事件配置之前被调用</li>
<li>注意：此时，无法获取 data中的数据、methods中的方法</li>
</ul>
<h3 id="钩子函数-created">钩子函数 - <strong>created()</strong></h3>
<ul>
<li>注意：这是一个常用的生命周期，可以调用methods中的方法、改变data中的数据</li>
<li><a href="https://segmentfault.com/a/1190000008879966">vue实例生命周期 参考1</a></li>
<li><a href="https://segmentfault.com/a/1190000008010666">vue实例生命周期 参考2</a></li>
<li>使用场景：发送请求获取数据</li>
</ul>
<h3 id="钩子函数-beforemounted">钩子函数 - beforeMounted()</h3>
<ul>
<li>说明：在挂载开始之前被调用</li>
</ul>
<h3 id="钩子函数-mounted">钩子函数 - <strong>mounted()</strong></h3>
<ul>
<li>说明：此时，vue实例已经挂载到页面中，可以获取到el中的DOM元素，进行DOM操作</li>
</ul>
<h3 id="钩子函数-beforeupdated">钩子函数 - beforeUpdated()</h3>
<ul>
<li>说明：数据更新时调用，发生在虚拟 DOM 重新渲染和打补丁之前。你可以在这个钩子中进一步地更改状态，这不会触发附加的重渲染过程。</li>
<li>注意：此处获取的数据是更新后的数据，但是获取页面中的DOM元素是更新之前的</li>
</ul>
<h3 id="钩子函数-updated">钩子函数 - updated()</h3>
<ul>
<li>说明：组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。</li>
</ul>
<h3 id="钩子函数-beforedestroy">钩子函数 - beforeDestroy()</h3>
<ul>
<li>说明：实例销毁之前调用。在这一步，实例仍然完全可用。</li>
<li>使用场景：实例销毁之前，执行清理任务，比如：清除定时器等</li>
</ul>
<h3 id="钩子函数-destroyed">钩子函数 - destroyed()</h3>
<ul>
<li>说明：Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。</li>
</ul>
<h2 id="自定义指令">自定义指令</h2>
<ul>
<li>作用：进行DOM操作</li>
<li>使用场景：对纯 DOM 元素进行底层操作，比如：文本框获得焦点</li>
<li><a href="https://juejin.im/entry/58b7c5d8ac502e006cfee34a">vue 自定义指令用法实例</a></li>
<li>两种指令：1 全局指令 2 局部指令</li>
</ul>
<h3 id="全局自定义指令">全局自定义指令</h3>
<pre><code class="language-javascript">// 第一个参数：指令名称
// 第二个参数：配置对象，指定指令的钩子函数
Vue.directive('directiveName', {
  // bind中只能对元素自身进行DOM操作，而无法对父级元素操作
  // 只调用一次 指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。
  bind( el，binding, vnode ) {
    // 参数详解
    // el：指令所绑定的元素，可以用来直接操作 DOM 。
    // binding：一个对象，包含以下属性：
      // name：指令名，不包括 v- 前缀。
      // value：指令的绑定值，等号后面的值 。
      // oldValue：指令绑定的前一个值，仅在 update 和 componentUpdated 钩子中可用。无论值是否改变都可用。
      // expression：字符串形式的指令表达式 等号后面的字符串 形式
      // arg：传给指令的参数，可选。例如 v-my-directive:foo 中，参数为 &quot;foo&quot;。
      // modifiers：指令修饰符。例如：v-directive.foo.bar中，修饰符对象为 { foo: true, bar: true }。
    // vnode：Vue 编译生成的虚拟节点。。
    // oldVnode：上一个虚拟节点，仅在 update 和 componentUpdated 钩子中可用。
  },
  // inserted这个钩子函数调用的时候，当前元素已经插入页面中了，也就是说可以获取到父级节点了
  inserted (  el，binding, vnode ) {},
  //  DOM重新渲染前
  update(el，binding, vnode,oldVnode) {},
  // DOM重新渲染后
  componentUpdated ( el，binding, vnode,oldVnode ) {},
  // 只调用一次，指令与元素解绑时调用
  unbind ( el ) {
    // 指令所在的元素在页面中消失，触发
  }
})
// 简写 如果你想在 bind 和 update 时触发相同行为，而不关心其它的钩子:
Vue.directive('自定义指令名', function( el, binding ) {})
// 例：
Vue.directive('color', function(el, binding) {
  el.style.color = binging.value
})
// 使用 注意直接些会被i成data中的数据“red” 需要字符串则嵌套引号&quot;'red'&quot;
&lt;p v-color=&quot;'red'&quot;&gt;&lt;/p&gt;
</code></pre>
<h3 id="局部自定义指令">局部自定义指令</h3>
<pre><code>var vm = new Vue({
  el : &quot;#app&quot;,
  directives: {
    directiveName: { }
  }
})
</code></pre>
<ul>
<li><a href="https://segmentfault.com/a/1190000006599500">vue 剖析Vue原理&amp;实现双向绑定MVVM</a></li>
</ul>
<h2 id="组件">组件</h2>
<blockquote>
<p>组件系统是 Vue 的另一个重要概念，因为它是一种抽象，允许我们使用小型、独立和通常可复用的组件构建大型应用。仔细想想，几乎任意类型的应用界面都可以抽象为一个组件树</p>
</blockquote>
<ul>
<li>创建组件的两种方式：1 全局组件 2 局部组件</li>
</ul>
<h3 id="全局组件">全局组件</h3>
<ul>
<li>说明：全局组件在所有的vue实例中都可以使用</li>
<li>注意：<strong>先注册组件，再初始化根实例</strong></li>
</ul>
<pre><code>// 1 注册全局组件  
Vue.component('my-component', {
  // template 只能有一个根元素
  template: '&lt;p&gt;A custom component!&lt;/p&gt;',
  // 组件中的 `data` 必须是函数 并且函数的返回值必须是对象
  data() {
    return {
      msg: '注意：组件的data必须是一个函数！！！'
    }
  }
})

// 2 使用：以自定义元素的方式
&lt;div id=&quot;example&quot;&gt;
  &lt;my-component&gt;&lt;/my-component&gt;
&lt;/div&gt;

// =====&gt; 渲染结果
&lt;div id=&quot;example&quot;&gt;
  &lt;p&gt;A custom component!&lt;/p&gt;
&lt;/div&gt;


// 3 template属性的值可以是：
  - 1 模板字符串
  - 2 模板id  template: '#tpl'
&lt;script type=&quot;text/x-template&quot; id=&quot;tpl&quot;&gt;
  &lt;p&gt;A custom component!&lt;/p&gt;
&lt;/script&gt;
</code></pre>
<ul>
<li><code>extend</code>：使用基础 Vue 构造器，创建一个“子类”。参数是一个包含组件选项的对象。</li>
</ul>
<pre><code>// 注册组件，传入一个扩展过的构造器
Vue.component('my-component', Vue.extend({ /* ... */ }))

// 注册组件，传入一个选项对象 (自动调用 Vue.extend)
Vue.component('my-component', { /* ... */ })

var Home = Vue.extend({
  template: '',
  data() {}
})
Vue.component('home', Home)
</code></pre>
<h3 id="局部组件">局部组件</h3>
<ul>
<li>说明：局部组件，是在某一个具体的vue实例中定义的，只能在这个vue实例中使用</li>
</ul>
<pre><code>var Child = {
  template: '&lt;div&gt;A custom component!&lt;/div&gt;'
}

new Vue({
  // 注意：此处为 components
  components: {
    // &lt;my-component&gt; 将只在当前vue实例中使用
    // my-component 为组件名 值为配置对象 
    'my-component': {
      template: ``,
      data () { return { } },
      props : []
    }
  }
})
</code></pre>
<h3 id="is特性">is特性</h3>
<blockquote>
<p>在某些特定的标签中只能存在指定表恰 如ul &gt; li 如果要浏览器正常解析则需要使用is</p>
</blockquote>
<pre><code>&lt;!-- 案例 --&gt;
&lt;ul id=&quot;app&quot;&gt;
  &lt;!-- 不能识别 --&gt;
  &lt;my-li&gt;&lt;/my-li&gt; 
  正常识别
  &lt;li is=&quot;my-li&quot;&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;script&gt;
  var vm = new Vue({
    el: &quot;#app&quot;,
    components : {
      myLi : {
        template : `&lt;li&gt;内容&lt;/li&gt;`
      }
    }
  })
&lt;/script&gt;
</code></pre>
<h2 id="组件通讯">组件通讯</h2>
<h3 id="父组件到子组件props">父组件到子组件(props)</h3>
<ul>
<li>方式：通过子组件<code>props</code>属性来传递数据 props是一个数组</li>
<li>注意：属性的值必须在组件中通过<code>props</code>属性显示指定，否则，不会生效</li>
<li>说明：传递过来的<code>props</code>属性的用法与<code>data</code>属性的用法相同</li>
</ul>
<pre><code>&lt;div id=&quot;app&quot;&gt;
  &lt;!-- 如果需要往子组件总传递父组件data中的数据 需要加v-bind=&quot;数据名称&quot; --&gt;
  &lt;hello v-bind:msg=&quot;info&quot;&gt;&lt;/hello&gt;
  &lt;!-- 如果传递的是字面量 那么直接写--&gt;
  &lt;hello my-msg=&quot;abc&quot;&gt;&lt;/hello&gt;
&lt;/div&gt;

&lt;!-- js --&gt;
&lt;script&gt;
  new Vue({
    el: &quot;#app&quot;,
    data : {
      info : 15
    },
    components: {
      hello: {
        // 创建props及其传递过来的属性
        props: ['msg', 'myMsg'],
        template: '&lt;h1&gt;这是 hello 组件，这是消息：{{msg}} --- {{myMsg}}&lt;/h1&gt;'
      }
    }
  })
&lt;/script&gt;
</code></pre>
<h3 id="子组件到父组件emit">子组件到父组件(emit)</h3>
<p>方式：父组件给子组件传递一个函数，由子组件调用这个函数</p>
<ul>
<li>说明：借助vue中的自定义事件（v-on:cunstomFn=&quot;fn&quot;）</li>
</ul>
<p>步骤:</p>
<ul>
<li>1、在父组件中定义方法 parentFn</li>
<li>2、在子组件 组件引入标签 中绑定自定义事件 v-on:自定义事件名=&quot;父组件中的方法&quot; ==&gt; @pfn=&quot;parentFn&quot;</li>
<li>3、子组件中通过<code>$emit()</code>触发自定义事件事件 this.$emit(pfn,参数列表。。。)</li>
</ul>
<pre><code>&lt;hello @pfn=&quot;parentFn&quot;&gt;&lt;/hello&gt;

&lt;script&gt;
  Vue.component('hello', {
    template: '&lt;button @click=&quot;fn&quot;&gt;按钮&lt;/button&gt;',
    methods: {
      // 子组件：通过$emit调用
      fn() {
        this.$emit('pfn', '这是子组件传递给父组件的数据')
      }
    }
  })
  new Vue({
    methods: {
      // 父组件：提供方法
      parentFn(data) {
        console.log('父组件：', data)
      }
    }
  })
&lt;/script&gt;
</code></pre>
<h3 id="非父子组件通讯">非父子组件通讯</h3>
<h4 id="eventbus不建议使用之后会弃用">eventbus(不建议使用,之后会弃用)</h4>
<blockquote>
<p>在简单的场景下，可以使用一个空的 Vue 实例作为事件总线</p>
</blockquote>
<ul>
<li><code>$on()</code>：绑定自定义事件(不建议使用,之后会弃用)</li>
</ul>
<pre><code>var bus = new Vue()

// 在组件 B 绑定自定义事件
bus.$on('id-selected', function (id) {
  // ...
})
// 触发组件 A 中的事件
bus.$emit('id-selected', 1)
</code></pre>
<ul>
<li>示例：组件A ---&gt; 组件B</li>
</ul>
<pre><code>&lt;!-- 组件A： --&gt;
&lt;com-a&gt;&lt;/com-a&gt;
&lt;!-- 组件B： --&gt;
&lt;com-b&gt;&lt;/com-b&gt;

&lt;script&gt;
  // 中间组件
  var bus = new Vue()
  // 通信组件
  var vm = new Vue({
    el: '#app',
    components: {
      comB: {
        template: '&lt;p&gt;组件A告诉我：{{msg}}&lt;/p&gt;',
        data() {
          return {
            msg: ''
          }
        },
        created() {
          // 给中间组件绑定自定义事件 注意:如果用到this 需要用箭头函数
          bus.$on('tellComB', (msg) =&gt; {
            this.msg = msg
          })
        }
      },
      comA: {
        template: '&lt;button @click=&quot;emitFn&quot;&gt;告诉B&lt;/button&gt;',
        methods: {
          emitFn() {
            // 触发中间组件中的自定义事件
            bus.$emit('tellComB', '土豆土豆我是南瓜')
          }
        }
      }
    }
  })
&lt;/script&gt;
</code></pre>
<h4 id="ref和refs"><code>ref和refs</code></h4>
<p><code>ref</code>：如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例，可以通过实例直接调用组件的方法或访问数据， 我们看一个<code>ref</code> 来访问组件的例子:</p>
<pre><code>// 子组件 A.vue

export default {
  data () {
    return {
      name: 'Vue.js'
    }
  },
  methods: {
    sayHello () {
      console.log('hello')
    }
  }
}
复制代码
// 父组件 app.vue

&lt;template&gt;
  &lt;component-a ref=&quot;comA&quot;&gt;&lt;/component-a&gt;
&lt;/template&gt;
&lt;script&gt;
  export default {
    mounted () {
      const comA = this.$refs.comA;
      console.log(comA.name);  // Vue.js
      comA.sayHello();  // hello
    }
  }
&lt;/script&gt;
</code></pre>
<h4 id="localstorage-sessionstorage"><code>localStorage</code> / <code>sessionStorage</code></h4>
<p>这种通信比较简单,缺点是数据和状态比较混乱,不太容易维护。 通过<code>window.localStorage.getItem(key)</code>获取数据 通过<code>window.localStorage.setItem(key,value)</code>存储数据</p>
<blockquote>
<p>注意用<code>JSON.parse()</code> / <code>JSON.stringify()</code> 做数据格式转换 <code>localStorage</code> / <code>sessionStorage</code>可以结合<code>vuex</code>, 实现数据的持久保存,同时使用vuex解决数据和状态混乱问题.</p>
</blockquote>
<h4 id="三-provide-inject">三、<code>provide</code>/ <code>inject</code></h4>
<blockquote>
<p>概念:</p>
</blockquote>
<p><code>provide</code>/ <code>inject</code> 是<code>vue2.2.0</code>新增的api, 简单来说就是父组件中通过<code>provide</code>来提供变量, 然后再子组件中通过<code>inject</code>来注入变量。</p>
<blockquote>
<p>注意: 这里不论子组件嵌套有多深, 只要调用了<code>inject</code> 那么就可以注入<code>provide</code>中的数据，而不局限于只能从当前父组件的props属性中回去数据</p>
</blockquote>
<blockquote>
<p>举例验证</p>
</blockquote>
<p>接下来就用一个例子来验证上面的描述: 假设有三个组件: A.vue、B.vue、C.vue 其中 C是B的子组件，B是A的子组件</p>
<pre><code>// A.vue

&lt;template&gt;
  &lt;div&gt;
	&lt;comB&gt;&lt;/comB&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
  import comB from '../components/test/comB.vue'
  export default {
    name: &quot;A&quot;,
    provide: {
      for: &quot;demo&quot;
    },
    components:{
      comB
    }
  }
&lt;/script&gt;
复制代码
// B.vue

&lt;template&gt;
  &lt;div&gt;
    {{demo}}
    &lt;comC&gt;&lt;/comC&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
  import comC from '../components/test/comC.vue'
  export default {
    name: &quot;B&quot;,
    inject: ['for'],
    data() {
      return {
        demo: this.for
      }
    },
    components: {
      comC
    }
  }
&lt;/script&gt;
复制代码
// C.vue
&lt;template&gt;
  &lt;div&gt;
    {{demo}}
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
  export default {
    name: &quot;C&quot;,
    inject: ['for'],
    data() {
      return {
        demo: this.for
      }
    }
  }
&lt;/script&gt;
</code></pre>
<h4 id="vuex状态管理">vuex状态管理</h4>
<p>一般全局的数据处理可以使用,不再赘述</p>
<h3 id="内容分发插槽">内容分发(插槽)</h3>
<p>这个比较复杂,建议直接看文档 <a href="https://cn.vuejs.org/v2/guide/components-slots.html">插槽使用</a><br>
案例：</p>
<pre><code>&lt;!-- html代码 --&gt;
&lt;div id=&quot;app&quot;&gt;
  &lt;hello&gt;
    &lt;!-- 如果只有一个slot插槽 那么不需要指定名称 --&gt;
    &lt;p slot=&quot;插槽名称&quot;&gt;我是额外的内容&lt;/p&gt;
  &lt;/hello&gt;
&lt;/div&gt;
// js代码
new vue({
  el : &quot;#app&quot;,
  components : {
    hello : {
      template : `
          &lt;div&gt;
            &lt;p&gt;我是子组件中的内容&lt;/p&gt;
            &lt;slot name=&quot;名称&quot;&gt;&lt;/slot&gt;
          &lt;/div&gt;
        `
    }
  }
})
</code></pre>
<h3 id="获取组件或元素-refs">获取组件（或元素） - refs</h3>
<ul>
<li>说明：<code>vm.$refs</code> 一个对象，持有已注册过 ref 的所有子组件（或HTML元素）</li>
<li>使用：在 HTML元素 中，添加<code>ref</code>属性，然后在JS中通过<code>vm.$refs.属性</code>来获取</li>
<li>注意：如果获取的是一个子组件，那么通过ref就能获取到子组件中的data和methods</li>
</ul>
<pre><code>&lt;div id=&quot;app&quot;&gt;
  &lt;div ref=&quot;dv&quot;&gt;&lt;/div&gt;
  &lt;my res=&quot;my&quot;&gt;&lt;/my&gt;
&lt;/div&gt;

&lt;!-- js --&gt;
&lt;script&gt;
  new Vue({
    el : &quot;#app&quot;,
    mounted() {
      this.$refs.dv //获取到元素
      this.$refs.my //获取到组件
    },
    components : {
      my : {
        template: `&lt;a&gt;sss&lt;/a&gt;`
      }
    }
  })
&lt;/script&gt;
</code></pre>
<h2 id="路由">路由</h2>
<p>详细内容和案例见    [链接](https://www.yuque.com/docs/share/2fcfcf69-9fab-4877-966d-50c5740e9226?# 《vue-router教程》)</p>
<ul>
<li>路由即：浏览器中的哈希值（# hash）与展示视图内容（template）之间的对应规则</li>
<li>vue中的路由是：hash 和 component的对应关系<br>
在 Web app 中，通过一个页面来展示和管理整个应用的功能。<br>
SPA往往是功能复杂的应用，为了有效管理所有视图内容，前端路由 应运而生！<br>
简单来说，路由就是一套映射规则（一对一的对应规则），由开发人员制定规则。<br>
当URL中的哈希值（# hash）发生改变后，路由会根据制定好的规则，展示对应的视图内容</li>
</ul>
<h3 id="基本使用">基本使用</h3>
<ul>
<li>安装：npm i -S vue-router</li>
</ul>
<pre><code>    &lt;div id=&quot;app&quot;&gt;
      &lt;!-- 5 路由入口 指定跳转到只定入口 --&gt;
      &lt;router-link to=&quot;/home&quot;&gt;首页&lt;/router-link&gt;
      &lt;router-link to=&quot;/login&quot;&gt;登录&lt;/router-link&gt;
    
      &lt;!-- 7 路由出口：用来展示匹配路由视图内容 --&gt;
      &lt;router-view&gt;&lt;/router-view&gt;
    &lt;/div&gt;
    
    &lt;!-- 1 导入 vue.js --&gt;
    &lt;script src=&quot;./vue.js&quot;&gt;&lt;/script&gt;
    &lt;!-- 2 导入 路由文件 --&gt;
    &lt;script src=&quot;./node_modules/vue-router/dist/vue-router.js&quot;&gt;&lt;/script&gt;
    &lt;script&gt;
      // 3 创建两个组件
      const Home = Vue.component('home', {
        template: '&lt;h1&gt;这是 Home 组件&lt;/h1&gt;'
      })
      const Login = Vue.component('login', {
        template: '&lt;h1&gt;这是 Login 组件&lt;/h1&gt;'
      })
    
      // 4 创建路由对象
      const router = new VueRouter({
        routes: [
          // 路径和组件一一对应
          { path: '/home', component: Home },
          { path: '/login', component: Login }
        ]
      })
    
      var vm = new Vue({
        el: '#app',
        // 6 将路由实例挂载到vue实例
        router
      })
    &lt;/script&gt;
</code></pre>
<h3 id="重定向">重定向</h3>
<pre><code>//  将path 重定向到 redirect
{ path: '/', redirect: '/home' }
</code></pre>
<h3 id="路由其他配置">路由其他配置</h3>
<ul>
<li>路由导航高亮
<ul>
<li>说明：当前匹配的导航链接，会自动添加router-link-exact-active router-link-active类</li>
<li>配置：linkActiveClass</li>
</ul>
</li>
<li>匹配路由模式
<ul>
<li>配置：mode</li>
</ul>
</li>
</ul>
<pre><code>new Router({
  routers:[],
  mode: &quot;hash&quot;, //默认hash | history 可以达到隐藏地址栏hash值 | abstract，如果发现没有浏览器的 API 则强制进入
  linkActiveClass : &quot;now&quot; //当前匹配的导航链接将被自动添加now类
})
</code></pre>
<h3 id="路由参数">路由参数</h3>
<ul>
<li>说明：我们经常需要把某种模式匹配到的所有路由，全都映射到同一个组件，此时，可以通过路由参数来处理</li>
<li>语法：/user/:id</li>
<li>使用：当匹配到一个路由时，参数值会被设置到 this.$route.params</li>
<li>其他：可以通过 $route.query 获取到 URL 中的查询参数 等</li>
</ul>
<pre><code>    // 方式一
    &lt;router-link to=&quot;/user/1001&quot;&gt;如果你需要在模版中使用路由参数 可以这样 {{$router.params.id}}&lt;/router-link&gt;
    // 方式二
    &lt;router-link :to=&quot;{path:'/user',query:{name:'jack',age:18}}&quot;&gt;用户 Rose&lt;/router-link&gt;


    &lt;script&gt;
    // 路由
    var router = new Router({
      routers : [
        // 方式一 注意 只有/user/1001这种形式能被匹配 /user | /user/ | /user/1001/ 都不能被匹配
        // 将来通过$router.params获取参数返回 {id:1001}
        { path: '/user/:id', component: User }, 
        // 方式二
        { path: &quot;user&quot; , component: User}
      ]
    })
    
    // User组件：
    const User = {
      template: `&lt;div&gt;User {{ $route.params.id }}&lt;/div&gt;`
    }
    &lt;/script&gt;  
    &lt;!-- 如果要子啊vue实例中获取路由参数 则使用this.$router.params 获取路由参数对象 --&gt;
    &lt;!--  {{$router.query}} 获取路由中的查询字符串 返回对象 --&gt;
</code></pre>
<h3 id="嵌套路由-子路由">嵌套路由 - 子路由</h3>
<ul>
<li>路由是可以嵌套的，即：路由中又包含子路由</li>
<li>规则：父组件中包含 router-view，在路由规则中使用 children 配置</li>
</ul>
<pre><code>    // 父组件：
    const User = Vue.component('user', {
      template: `
        &lt;div class=&quot;user&quot;&gt;
          &lt;h2&gt;User Center&lt;/h2&gt;
          &lt;router-link to=&quot;/user/profile&quot;&gt;个人资料&lt;/router-link&gt;
          &lt;router-link to=&quot;/user/posts&quot;&gt;岗位&lt;/router-link&gt;
          &lt;!-- 子路由展示在此处 --&gt;
          &lt;router-view&gt;&lt;/router-view&gt;
        &lt;/div&gt;
        `
    })
    
    // 子组件[简写]
    const UserProfile = {
      template: '&lt;h3&gt;个人资料：张三&lt;/h3&gt;'
    }
    const UserPosts = {
      template: '&lt;h3&gt;岗位：FE&lt;/h3&gt;'
    }
    
    // 路由
    var router =new Router({
      routers : [

        { path: '/user', component: User,
          // 子路由配置：
          children: [
            {
              // 当 /user/profile 匹配成功，
              // UserProfile 会被渲染在 User 的 &lt;router-view&gt; 中
              path: 'profile',
              component: UserProfile
            },
            {
              // 当 /user/posts 匹配成功
              // UserPosts 会被渲染在 User 的 &lt;router-view&gt; 中
              path: 'posts',
              component: UserPosts
            }
          ]
        }
      ]
    })
</code></pre>
<h2 id="vuex状态管理-2">vuex状态管理</h2>
<p>这个一般非专业前端也用不到,跳过</p>
<p>详细见<a href="https://vuex.vuejs.org/zh/">vuex官网</a></p>
<h2 id="spa-单页应用程序">SPA -单页应用程序</h2>
<h3 id="spa-single-page-application">SPA： Single Page Application</h3>
<pre><code>单页Web应用（single page application，SPA），就是只有一个Web页面的应用，
是加载单个HTML页面，并在用户与应用程序交互时动态更新该页面的Web应用程序。
</code></pre>
<ul>
<li>单页面应用程序：
<ul>
<li>只有第一次会加载页面, 以后的每次请求, 仅仅是获取必要的数据.然后, 由页面中js解析获取的数据, 展示在页面中</li>
</ul>
</li>
<li>传统多页面应用程序：
<ul>
<li>对于传统的多页面应用程序来说, 每次请求服务器返回的都是一个完整的页面</li>
</ul>
</li>
</ul>
<p>优势</p>
<ul>
<li>1 减少了请求体积，加快页面响应速度，降低了对服务器的压力</li>
<li>2 更好的用户体验，让用户在web app感受native app的流畅</li>
</ul>
<p>实现思路和技术点</p>
<ul>
<li>1 ajax</li>
<li>2 锚点的使用（window.location.hash #）</li>
<li>3 hashchange 事件 window.addEventListener(&quot;hashchange&quot;,function () {})</li>
<li>4 监听锚点值变化的事件，根据不同的锚点值，请求相应的数据</li>
<li>5 原本用作页面内部进行跳转，定位并展示相应的内容</li>
</ul>
<h2 id="前端模块化">前端模块化</h2>
<blockquote>
<p>为什么需要模块化</p>
</blockquote>
<ul>
<li>1 最开始的js就是为了实现客户端验证以及一些简单的效果</li>
<li>2 后来，js得到重视，应用越来越广泛，前端开发的复杂度越来越高</li>
<li>3 旧版本的js中没有提供与模块（module）相关的内容</li>
</ul>
<h3 id="模块的概念">模块的概念</h3>
<ul>
<li>在js中，一个模块就是实现特定功能的文件（js文件）</li>
<li>遵循模块的机制，想要什么功能就加载什么模块</li>
<li>模块化开发需要遵循规范</li>
</ul>
<h3 id="模块化解决的问题">模块化解决的问题</h3>
<ul>
<li>1 命名冲突</li>
<li>2 文件依赖（加载文件）</li>
<li>3 模块的复用</li>
<li>4 统一规范和开发方式</li>
</ul>
<h3 id="js实现模块化的规范">JS实现模块化的规范</h3>
<ul>
<li>AMD 浏览器端
<ul>
<li>requirejs</li>
</ul>
</li>
<li>CommonJS nodejs
<ul>
<li>加载模块：require()</li>
<li>导出模块：module.exports = {} / exports = {}</li>
</ul>
</li>
<li>ES6 中的 import / export</li>
<li>CMD 浏览器端
<ul>
<li>玉伯（阿里前端大神） -&gt; seajs</li>
</ul>
</li>
<li>UMD 通用模块化规范，可以兼容 AMD、CommonJS、浏览器中没有模块化规范 等这些语法</li>
</ul>
<p>AMD 的使用</p>
<blockquote>
<p>Asynchronous Module Definition：异步模块定义，浏览器端模块开发的规范 代表：require.js 特点：模块被异步加载，模块加载不影响后面语句的运行</p>
</blockquote>
<p>1、定义模块</p>
<pre><code>    // 语法:define(name, dependencies?, factory);
    // name表示：当前模块的名称，是一个字符串 可有可无
    // dependencies表示：当前模块的依赖项，是一个数组无论依赖一项还是多项 无则不写
    // factory表示：当前模块要完成的一些功能，是一个函数
    
    // 定义对象模块
    define({})
    // 定义方法模块
    define(function() {
      return {}
    })
    // 定义带有依赖项的模块
    define(['js/a'], function() {})
</code></pre>
<p>2、加载模块</p>
<pre><code>// - 注意：require的第一个参数必须是数组

    // 参数必须是数组 表示模块路径 以当前文件为基准,通过回调函数中的参数获取加载模块中的变量 参数与模块按照顺序一一对应
    require(['a', 'js/b'], function(a, b) {
      // 使用模块a 和 模块b 中的代码
    })
</code></pre>
<p>3、路径查找配置</p>
<ul>
<li>requirejs 默认使用 baseUrl+paths 的路径解析方式</li>
<li>可以使用以下方式避开此设置：
<ul>
<li>1 以.js结尾</li>
<li>2 以 / 开始</li>
<li>3 包含协议：https:// 或 http://</li>
</ul>
</li>
</ul>
<pre><code>// 配置示例
    // 注意配置应当在使用之前
    require.config({
      baseUrl: './js' // 配置基础路径为：当前目录下的js目录
    })
    require(['a'])    // 查找 基础路径下的 ./js/a.js

// 简化加载模块路径
    require.config({
      baseUrl: './js',
      // 配置一次即可，直接通过路径名称（template || jquery）加载模块
      paths: {
        template: 'assets/artTemplate/template-native',
        jquery: 'assets/jquery/jquery.min'
      }
    })
    // 加载jquery template模块
    require(['jquery', 'template'])
</code></pre>
<p>4、非模块化和依赖项支持</p>
<ul>
<li>1 添加模块的依赖模块，保证加载顺序（deps）</li>
<li>2 将非模块化模块，转化为模块化（exports）</li>
</ul>
<pre><code>// 示例
    require.config({
      baseUrl: './js',
      paths: {
        // 配置路径
        noModule: 'assets/demo/noModule'
      },
      // 配置不符合规范的模块项
      shim: {
        // 模块名称
        noModule: {
          deps: [],         // 依赖项
          exports: 'sayHi'  // 导出模块中存在的函数或变量
        }
      }
    });

// 注意点  如果定义模块的时候，指定了模块名称，需要使用该名称来引用模块
    // 定义 这个模块名称与paths中的名称相同
    define('moduleA', function() {})
    // 导入
    require.config({
      paths: {
        // 此处的模块名：moduleA
        moduleA: 'assets/demo/moduleA'
      }
    })
</code></pre>
<p>5、路径加载规则</p>
<ul>
<li>路径配置的优先级：
<ul>
<li>1 通过 config 配置规则查找</li>
<li>2 通过 data-main 指定的路径查找</li>
<li>3 以引入 requirejs 的页面所在路径为准查找</li>
</ul>
</li>
</ul>
<pre><code>    &lt;!-- 
      设置data-main属性
      1 data-main属性指定的文件也会同时被加载
      2 用于指定查找其他模块的基础路径
    --&gt;
    &lt;script src=&quot;js/require.js&quot; data-main=&quot;js/main&quot;&gt;&lt;/script&gt;
</code></pre>
<h2 id="axios">axios</h2>
<ul>
<li>Promise based HTTP client for the browser and node.js
<ul>
<li>以Promise为基础的HTTP客户端，适用于：浏览器和node.js</li>
<li>封装ajax，用来发送请求，异步获取数据</li>
</ul>
</li>
<li>安装：<code>yarn add axios</code></li>
<li><a href="https://github.com/axios/axios">axios</a></li>
</ul>
<pre><code class="language-javascript">// 在浏览器中使用，直接引入js文件使用下面的GET/POST请求方式即可
// 1 引入 axios.js
// 2 直接调用axios提供的API发送请求
created() {
  axios.get(url)
    .then(function(resp) {})
}

---
// 配合 webpack 使用方式如下：
import Vue from 'vue'
import axios from 'axios'
// 将 axios 添加到 Vue.prototype 中
Vue.prototype.$axios = axios

---
// 在组件中使用：
methods: {
  getData() {
    this.$axios.get('url')
      .then(res =&gt; {})
      .catch(err =&gt; {})
  }
}

---
// API使用方式：

axios.get(url[, config])
axios.post(url[, data[, config]])
axios(url[, config])
axios(config)
</code></pre>
<h3 id="get-请求">Get 请求</h3>
<pre><code class="language-javascript">const url = 'http://vue.studyit.io/api/getnewslist'

// url中带有query参数
axios.get('/user?id=89')
  .then(function (response) {
    console.log(response);
  })
  .catch(function (error) {
    console.log(error);
  });

// url和参数分离，使用对象
axios.get('/user', {
  params: {
    id: 12345
  }
})
</code></pre>
<h3 id="post-请求">Post 请求</h3>
<ul>
<li><a href="https://github.com/axios/axios#using-applicationx-www-form-urlencoded-format">不同环境中处理 POST请求</a></li>
<li>默认情况下，axios 会将JS对象序列化为JSON对象。为了使用 <code>application/x-www-form-urlencoded</code> 格式发送请求，我们可以这样：</li>
</ul>
<pre><code class="language-javascript">// 使用 qs 包，处理将对象序列化为字符串
// npm i -S qs
// var qs = require('qs')
import qs from 'qs'
qs.stringify({ 'bar': 123 }) ===&gt; &quot;bar=123&quot;
axios.post('/foo', qs.stringify({ 'bar': 123 }))

// 或者：
axios.post('/foo', 'bar=123&amp;age=19')
const url = 'http://vue.studyit.io/api/postcomment/17'
axios.post(url, 'content=点个赞不过份')

axios.post('/user', qs.stringify({
    firstName: 'Fred',
    lastName: 'Flintstone'
  }))
  .then(function (response) {
    console.log(response);
  })
  .catch(function (error) {
    console.log(error);
  });
</code></pre>
<h3 id="全局配置">全局配置</h3>
<pre><code>// 设置请求公共路径：
axios.defaults.baseURL = 'http://vue.studyit.io'
</code></pre>
<h3 id="拦截器">拦截器</h3>
<ul>
<li>拦截器会拦截发送的每一个请求，请求发送之前执行<code>request</code>中的函数，请求发送完成之后执行<code>response</code>中的函数</li>
</ul>
<pre><code class="language-javascript">// 请求拦截器
axios.interceptors.request.use(function (config) {
    // 所有请求之前都要执行的操作

    return config;
  }, function (error) {
    // 错误处理

    return Promise.reject(error);
  });

// 响应拦截器
axios.interceptors.response.use(function (response) {
    // 所有请求完成后都要执行的操作

    return response;
  }, function (error) {
    // 错误处理
    return Promise.reject(error);
  });
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[安装 Kali Linux 后需要做的 20 件事]]></title>
        <id>https://copyer98.github.io/post/安装 Kali Linux 后需要做的 20 件事/</id>
        <link href="https://copyer98.github.io/post/安装 Kali Linux 后需要做的 20 件事/">
        </link>
        <updated>2019-01-08T04:17:00.000Z</updated>
        <summary type="html"><![CDATA[<p>##安装 Kali Linux 后需要做的 20 件事</p>
<ul>
<li><strong>专门针对Kali用户</strong></li>
</ul>
<p>Kali Linux是来自Debian的一个特殊版本，Kali Linux同样存在Debian Linux的许多问题。这部分为读者介绍如何解决那些问题。它们并不是Kali Linux特有的问题，你可以不用理它们；不过我看到错误，强迫症就会发作，非解决错误不可。</p>
<ul>
<li><strong>实用工具和软件</strong></li>
</ul>
<p>这部分汇集了我觉得有用的一批实用工具和软件。这些是大多数其他Linux发行版里面也有的日常软件，或者至少我认为它们应作为默认安装系统的一部分而出现。</p>
<ul>
<li><strong>改进和辅助功能</strong></li>
</ul>
<p>Kali Linux天生具有启动速度快、占用资源少的特点。但如果你有一些CPU和GPU能力可用，不妨试着让Kali Linix的外观更靓丽一些。</p>
<p><strong>专门针对Kali用户</strong></p>
<p><strong>1. 解决有线网络的&quot;设备无法托管&quot;错误</strong></p>
<p>如果你希望NetworkManager（网络管理器）处理在/etc/network/interfaces中启用的接口，只要在/etc/NetworkManager/NetworkManager.conf中设置managed=true。所以，该文件看起来就像：</p>
<pre><code>[main] plugins=ifupdown,keyfile [ifupdown] managed=true 
</code></pre>
<figure data-type="image" tabindex="1"><a href="http://s9.51cto.com/wyfs02/M02/27/A3/wKioL1N0Hy-i06pCAAAgIjTDXr8423.jpg"><img src="http://s9.51cto.com/wyfs02/M02/27/A3/wKioL1N0Hy-i06pCAAAgIjTDXr8423.jpg" alt="img" loading="lazy"></a></figure>
<p>请阅读全文：《<a href="http://www.blackmoreops.com/2013/11/25/how-to-fix-wired-network-interface-device-not-managed-error/">Debian或Kali Linux中解决有线网络接口的&quot;设备无法托管&quot;错误</a>》。</p>
<p><strong>2. 修复默认的软件库</strong></p>
<p>最简单的办法就是，编辑/etc/apt/sources.list，去掉每一行或在开头用#注释每一行，并添加下面这几行：</p>
<pre><code>leafpad /etc/apt/sources.list 
</code></pre>
<p>用下面几行，注释或去掉现有的配置：</p>
<pre><code>## Regular repositories deb http://http.kali.org/kali kali main non-free contrib deb http://security.kali.org/kali-security kali/updates main contrib non-free ## Source repositories deb-src http://http.kali.org/kali kali main non-free contrib deb-src http://security.kali.org/kali-security kali/updates main contrib non-free 
</code></pre>
<p>保存并关闭文件。想了解相关细节和介绍，请参阅《<a href="http://www.blackmoreops.com/2013/10/30/add-official-kali-linux-repositories/">添加官方的Kali Linux软件库</a>》一文。</p>
<p><strong>3. 更新、升级和发行版升级</strong></p>
<p>对你安装的Kali进行清洁、更新、升级和发行版升级等处理。</p>
<pre><code>apt-get clean &amp;&amp; apt-get update &amp;&amp; apt-get upgrade -y &amp;&amp; apt-get dist-upgrade -y 
</code></pre>
]]></summary>
        <content type="html"><![CDATA[<p>##安装 Kali Linux 后需要做的 20 件事</p>
<ul>
<li><strong>专门针对Kali用户</strong></li>
</ul>
<p>Kali Linux是来自Debian的一个特殊版本，Kali Linux同样存在Debian Linux的许多问题。这部分为读者介绍如何解决那些问题。它们并不是Kali Linux特有的问题，你可以不用理它们；不过我看到错误，强迫症就会发作，非解决错误不可。</p>
<ul>
<li><strong>实用工具和软件</strong></li>
</ul>
<p>这部分汇集了我觉得有用的一批实用工具和软件。这些是大多数其他Linux发行版里面也有的日常软件，或者至少我认为它们应作为默认安装系统的一部分而出现。</p>
<ul>
<li><strong>改进和辅助功能</strong></li>
</ul>
<p>Kali Linux天生具有启动速度快、占用资源少的特点。但如果你有一些CPU和GPU能力可用，不妨试着让Kali Linix的外观更靓丽一些。</p>
<p><strong>专门针对Kali用户</strong></p>
<p><strong>1. 解决有线网络的&quot;设备无法托管&quot;错误</strong></p>
<p>如果你希望NetworkManager（网络管理器）处理在/etc/network/interfaces中启用的接口，只要在/etc/NetworkManager/NetworkManager.conf中设置managed=true。所以，该文件看起来就像：</p>
<pre><code>[main] plugins=ifupdown,keyfile [ifupdown] managed=true 
</code></pre>
<figure data-type="image" tabindex="1"><a href="http://s9.51cto.com/wyfs02/M02/27/A3/wKioL1N0Hy-i06pCAAAgIjTDXr8423.jpg"><img src="http://s9.51cto.com/wyfs02/M02/27/A3/wKioL1N0Hy-i06pCAAAgIjTDXr8423.jpg" alt="img" loading="lazy"></a></figure>
<p>请阅读全文：《<a href="http://www.blackmoreops.com/2013/11/25/how-to-fix-wired-network-interface-device-not-managed-error/">Debian或Kali Linux中解决有线网络接口的&quot;设备无法托管&quot;错误</a>》。</p>
<p><strong>2. 修复默认的软件库</strong></p>
<p>最简单的办法就是，编辑/etc/apt/sources.list，去掉每一行或在开头用#注释每一行，并添加下面这几行：</p>
<pre><code>leafpad /etc/apt/sources.list 
</code></pre>
<p>用下面几行，注释或去掉现有的配置：</p>
<pre><code>## Regular repositories deb http://http.kali.org/kali kali main non-free contrib deb http://security.kali.org/kali-security kali/updates main contrib non-free ## Source repositories deb-src http://http.kali.org/kali kali main non-free contrib deb-src http://security.kali.org/kali-security kali/updates main contrib non-free 
</code></pre>
<p>保存并关闭文件。想了解相关细节和介绍，请参阅《<a href="http://www.blackmoreops.com/2013/10/30/add-official-kali-linux-repositories/">添加官方的Kali Linux软件库</a>》一文。</p>
<p><strong>3. 更新、升级和发行版升级</strong></p>
<p>对你安装的Kali进行清洁、更新、升级和发行版升级等处理。</p>
<pre><code>apt-get clean &amp;&amp; apt-get update &amp;&amp; apt-get upgrade -y &amp;&amp; apt-get dist-upgrade -y 
</code></pre>
<!--more-->
<p><strong>4. 解决PulseAudio警告问题</strong></p>
<p>我的Kali经常弹出这个警告信息：</p>
<pre><code>[warn] PulseAudio configured for per-user sessions ... (warning). 
</code></pre>
<p>Debian变种版本也会在启动过程中弹出类似的警告信息。为了解决这个问题，键入下面这个命令：</p>
<pre><code>leafpad /etc/default/pulseaudio 
</code></pre>
<p>找到这一行：</p>
<pre><code>PULSEAUDIO_SYSTEM_START=0 
</code></pre>
<p>把0换成1：</p>
<pre><code>PULSEAUDIO_SYSTEM_START=1 
</code></pre>
<p>其中，0表示系统模式下不启动PulseAudio，1表示系统模式下启动PulseAudio。</p>
<pre><code>reboot 
</code></pre>
<p>想了解相关细节和介绍，请参阅《<a href="http://www.blackmoreops.com/2013/10/12/fixing-pulseaudio-configured-for-per-user-sessions-warning-in-kali-linux/">解决Kali Linux中的PulseAudio configured for per-user sessions ...（warning）</a>》一文。</p>
<p><strong>5. 确保启动时发出声音</strong></p>
<p>遵照下列步骤，即可解决Kali Linux中启动时没有声音的问题。</p>
<pre><code>apt-get install alsa-utils -y 
</code></pre>
<p>在GNOME桌面（默认是Kali桌面）中：</p>
<p>鼠标右击小小的音量图标，选择Sound Preferences（声音首选项）。</p>
<p>此外，你还可以依次进入到Applications（应用程序）&gt; System Tools（系统工具）&gt; Preferences（首选项）&gt; System Settings（系统设置）&gt; Sound（声音），即可调出同样的选项。</p>
<p>将Output volume（输出音量）滑块切换到ON（打开），类似下面的屏幕截图。这就是你要做的。关闭Sound（声音）窗口。</p>
<figure data-type="image" tabindex="2"><a href="http://s2.51cto.com/wyfs02/M01/27/A3/wKiom1N0IObgDue-AACpKMTi3-c960.jpg-wh_600x-s_172056694.jpg"><img src="http://s2.51cto.com/wyfs02/M01/27/A3/wKiom1N0IObgDue-AACpKMTi3-c960.jpg-wh_600x-s_172056694.jpg" alt="img" loading="lazy"></a></figure>
<p>想了解相关细节和介绍，请参阅《<a href="http://www.blackmoreops.com/2014/01/16/fix-sound-mute-kali-linux-boot/">解决Kali Linux中启动时没有声音这个问题</a>》一文。</p>
<p><strong>实用工具和软件</strong></p>
<p><strong>6. 安装Java</strong></p>
<p>进入到下面这个链接，下载jdk7。截至本文截稿时，jdk版本是jdk-7u45-linux-x64。注意：我使用的是x64，即64位版本。32位版本用户应选择相应的版本。这其实不难！</p>
<figure data-type="image" tabindex="3"><a href="http://s6.51cto.com/wyfs02/M00/27/A3/wKiom1N0IRTQukfGAAArMCRuLXE293.jpg"><img src="http://s6.51cto.com/wyfs02/M00/27/A3/wKiom1N0IRTQukfGAAArMCRuLXE293.jpg" alt="img" loading="lazy"></a></figure>
<p>下面是我使用的方法。截至本文截稿时，可用版本是jdk-7u45-linux-x64.tar.gz。下载该文件，并保存在/root目录中。</p>
<pre><code>tar -xzvf /root/jdk-7u45-linux-x64.tar.gz mv jdk1.7.0_45 /opt cd /opt/jdk1.7.0_45 
</code></pre>
<p>这一步将已下载的Java版本登记为替代版本，将其改成作为默认版本来使用：</p>
<pre><code>update-alternatives --install /usr/bin/java java /opt/jdk1.7.0_45/bin/java 1 update-alternatives --install /usr/bin/javac javac /opt/jdk1.7.0_45/bin/javac 1 update-alternatives --install /usr/lib/mozilla/plugins/libjavaplugin.so mozilla-javaplugin.s /opt/jdk1.7.0_45/jre/lib/amd64/libnpjp2.so 1 update-alternatives --set java /opt/jdk1.7.0_45/bin/java update-alternatives --set javac /opt/jdk1.7.0_45/bin/javac update-alternatives --set mozilla-javaplugin.so /opt/jdk1.7.0_45/jre/lib/amd64/libnpjp2.so 
</code></pre>
<p>参阅《<a href="http://www.blackmoreops.com/2013/10/26/how-to-install-java-jdk-in-kali-linux/">在Kali Linux中安装Java JDK</a>》一文，即可详细了解逐步操作和测试选项。</p>
<p><strong>7. 安装Flash</strong></p>
<p>这件事情相当简单、容易，对大多数人来说应该没有问题：在终端中，键入这个命令：</p>
<pre><code>apt-get install flashplugin-nonfree 
</code></pre>
<p>然后键入：</p>
<pre><code>update-flashplugin-nonfree - -install 
</code></pre>
<p>就是这样。你的flash现在应该能够正常工作了。</p>
<figure data-type="image" tabindex="4"><a href="http://s6.51cto.com/wyfs02/M01/27/A4/wKioL1N0It3TyKrZAAAaS9wNA8A431.jpg"><img src="http://s6.51cto.com/wyfs02/M01/27/A4/wKioL1N0It3TyKrZAAAaS9wNA8A431.jpg" alt="img" loading="lazy"></a></figure>
<p>参阅《<a href="http://www.blackmoreops.com/2013/10/26/how-to-install-flash-in-kali-linux/">在Kali Linux中安装Flash</a>》一文，以便了解逐步操作和测试选项。如果有些人使用上述方法安装失败，该文还给出了Flash手动安装步骤。</p>
<p><strong>8. 安装File Roller（归档管理器）</strong></p>
<p>Kali Linux缺少一个真正的GUI归档管理器。使用下面这个命令来安装归档管理器（File Roller）：</p>
<pre><code>apt-get install unrar unace rar unrar p7zip zip unzip p7zip-full p7zip-rar file-roller -y 
</code></pre>
<p>现在你可以在Applications（应用程序）&gt; Accessories（附件）&gt; Archive Manager（归档管理器）中找到归档管理器。</p>
<p><strong>9. 添加标准用户</strong></p>
<p>默认情况下，Kali Linux只有root用户。虽然大多数应用程序需要root访问权，但添加第二个用户总归是个好主意。打开终端，键入下面这个命令，即可创建新用户（把user1换成你想要的用户名称）。</p>
<pre><code>useradd -m user1 
</code></pre>
<p>（注意：-m意味着创建通常是/home/username的主目录）</p>
<figure data-type="image" tabindex="5"><a href="http://s6.51cto.com/wyfs02/M02/27/A4/wKioL1N0IvbjIKVZAAA7MAScvTA573.jpg"><img src="http://s6.51cto.com/wyfs02/M02/27/A4/wKioL1N0IvbjIKVZAAA7MAScvTA573.jpg" alt="img" loading="lazy"></a></figure>
<p>现在为该用户设置密码：</p>
<pre><code>passwd user1 
</code></pre>
<p>将所需密码输入两次。添加用户到sudo群组（允许用户进行安装软件、允许打印、使用特权模式等操作）。</p>
<pre><code>usermod -a -G sudo user1 
</code></pre>
<p>（注意：-a意味着附加或添加，-G意味着指定一个群组/多个群组）。将之前创建的用户的默认外壳改成bash：</p>
<pre><code>chsh -s /bin/bash user1 
</code></pre>
<p>想了解更多内容，请参阅这篇详细而深入的文章：《如何在Kali Linux中添加/删除用户（标准用户/非root用户）》，参阅http://www.blackmoreops.com/2013/11/27/how-to-add-remove-user-standard-user-non-root-in-kali-linux/。该文解释了了如何添加用户，而所有的用户目录也已经到位（因而避免了&quot;无法更新.ICEauthority var/lib/gdm3/.ICEauthority&quot;或含有.ICEauthority或一般权限的任何错误。）</p>
<p><strong>10. 添加add-apt-repository</strong></p>
<p>Debian让用户可以通过一个名为add-apt-repository的应用程序，添加和使用PPA软件库，不过Kali Linux在其默认的程序包列表中并不含有该应用程序。就Kali而言，由于这是个特殊用途的应用程序，已进行了某些改动，以便让它适用于最擅长的地方（渗透测试）。想通过add-apt-repository应用程序启用PPA软件库，遵照下面几个步骤。</p>
<p>首先安装Python软件属性程序包。</p>
<pre><code>apt-get install python-software-properties 
</code></pre>
<p>接下来安装apt-file。</p>
<pre><code>apt-get install apt-file 
</code></pre>
<p>更新apt-file。</p>
<pre><code>apt-file update 
</code></pre>
<p>这需要一点时间，所以万一你的apt-file更新起来很慢，可能想试试一并解决这个问题。（注意：我的/etc/apt/sources.list文件中有repo.kali.org，而不是http.kali.org。）一旦apt-file更新完毕，你应该能够搜索它了。</p>
<pre><code>apt-file search add-apt-repository 
</code></pre>
<p>你的输出结果应该看起来类似这样：</p>
<pre><code>python-software-properties: /usr/bin/add-apt-repository python-software-properties: /usr/share/man/man1/add-apt-repository.1.gz 
</code></pre>
<p>位于/usr/bin/add-apt-repository的默认add-apt-repository应用程序适用于Debian。所以，如果你使用Kali，它很可能无法工作。我在本文末尾处添加了一个巧妙的解决办法，如果你喜欢的话，可以在VirtualBox上一下。但我发现，我们完全可以模仿Ubuntu Oneiric，让add-apt-repository正常工作。</p>
<pre><code>cd /usr/sbin vi add-apt-repository 
</code></pre>
<p>添加下列代码，并保存文件。</p>
<pre><code>#!/bin/bash if [ $# -eq 1 ] NM=`uname -a &amp;&amp; date` NAME=`echo $NM | md5sum | cut -f1 -d&quot; &quot;` then ppa_name=`echo &quot;$1&quot; | cut -d&quot;:&quot; -f2 -s` if [ -z &quot;$ppa_name&quot; ] then echo &quot;PPA name not found&quot; echo &quot;Utility to add PPA repositories in your debian machine&quot; echo &quot;$0 ppa:user/ppa-name&quot; else echo &quot;$ppa_name&quot; echo &quot;deb http://ppa.launchpad.net/$ppa_name/ubuntu oneiric main&quot; &gt;&gt; /etc/apt/sources.list apt-get update &gt;&gt; /dev/null 2&gt; /tmp/${NAME}_apt_add_key.txt key=`cat /tmp/${NAME}_apt_add_key.txt | cut -d&quot;:&quot; -f6 | cut -d&quot; &quot; -f3` apt-key adv --keyserver keyserver.ubuntu.com --recv-keys $key rm -rf /tmp/${NAME}_apt_add_key.txt fi else echo &quot;Utility to add PPA repositories in your debian machine&quot; echo &quot;$0 ppa:user/ppa-name&quot; fi 
</code></pre>
<p>注意：在echo &quot;deb http://ppa.launchpad.net/$ppa_name/ubuntu oneiric main&quot; &gt;&gt; /etc/apt/sources.list这一行中，我使用了Oneiric。你可以根据自己的选择，试着使用Lucid、Raring或Saucy。现在，使用chmod和chown这两个命令，对文件进行相应的操作。</p>
<pre><code>chmod +x /usr/sbin/add-apt-repository chown root:root /usr/sbin/add-apt-repository 
</code></pre>
<p>由于我们已添加了正确的代码，我们就可以使用add-apt-repository，添加PPA软件库。我试着输入下面这两个命令，在Kali Linux中添加主题和自定义图标。</p>
<pre><code>/usr/sbin/add-apt-repository ppa:noobslab/themes /usr/sbin/add-apt-repository ppa:alecive/antigone 
</code></pre>
<figure data-type="image" tabindex="6"><a href="http://s7.51cto.com/wyfs02/M00/27/A3/wKiom1N0I0DjXhX2AAFne0roxq4680.jpg-wh_600x-s_4088219889.jpg"><img src="http://s7.51cto.com/wyfs02/M00/27/A3/wKiom1N0I0DjXhX2AAFne0roxq4680.jpg-wh_600x-s_4088219889.jpg" alt="img" loading="lazy"></a></figure>
<p>我删除了本文中的所有屏幕截图，但如果你想看个清楚，了解具体是如何工作的，建议你参阅《<a href="http://www.blackmoreops.com/2014/02/21/kali-linux-add-ppa-repository-add-apt-repository/">在Kali Linux中添加PPA软件库add-apt-repository</a>》一文，了解更多细节。</p>
<p><strong>11. 安装Tor</strong></p>
<p>Tor是自由软件，也是一种开放网络，可以帮助你防御流量分析。流量分析是一种网络监视行为，会危及个人自由和隐私、机密性的商业活动和关系以及国家安全。该指南为你详细介绍了在Kali Linux中安装Tor的步骤。Tor保护你的方法是，通过由全球广大志愿者运营的一个分布式中转网络，传递你的通信内容：它可以防止有人监视你的互联网连接、进而了解你访问哪些网站，它还可以防止你访问的网站了解你的实际位址。</p>
<figure data-type="image" tabindex="7"><a href="http://s9.51cto.com/wyfs02/M01/27/A4/wKiom1N0I2GBapXSAACLWDMY0dw505.jpg-wh_600x-s_4269129613.jpg"><img src="http://s9.51cto.com/wyfs02/M01/27/A4/wKiom1N0I2GBapXSAACLWDMY0dw505.jpg-wh_600x-s_4269129613.jpg" alt="img" loading="lazy"></a></figure>
<p>Tor在Kali软件库中就用；想直接从软件库安装它，只要打开终端，键入这个命令：</p>
<pre><code>apt-get install tor 
</code></pre>
<p>从命令行启用Tor服务：</p>
<pre><code>service tor start 
</code></pre>
<p>使用proxychains命令和Tor，实现安全浏览：</p>
<pre><code>proxychains iceweasel 
</code></pre>
<p>为了在本文中确保行文简单，我只显示了使用Tor的一方面。你可以在《在Kali Linux中安装Tor》一文中详细阅读完整细节，详见http://www.blackmoreops.com/2013/12/16/installing-tor-kali-linux/。</p>
<p><strong>12. 安装Filezilla FTP客户端</strong></p>
<p>要是缺少功能完备的FTP客户端，任何Linux安装都谈不上是完整的。Filezilla是最好的FTP客户端，所以使用下面这个命令，安装Filezilla：</p>
<pre><code>apt-get install filezilla filezilla-common -y 
</code></pre>
<p><strong>13. 安装HTOP和NetHogs</strong></p>
<p>HTOP是个特别的工具，显示了运行中的进程和所使用的内存，包括更多的详细信息。（你也可以使用top命令，但HTOP完全有用得多。）NetHogs也很有用，它按接口显示了应用程序所用的流量。使用下面这个命令，安装这两个工具：</p>
<pre><code>apt-get install htop nethogs -y 
</code></pre>
<p>你现在可以使用下面几个命令来运行它们了：</p>
<pre><code>htop nethogs eth0 nethogs wlan0 
</code></pre>
<p>你会喜欢使用这些小巧工具的，这点我几乎可以肯定。</p>
<p><strong>14. 为显卡安装专有的驱动程序</strong></p>
<p>你可能需要安装专有的驱动程序，以发掘更多的功能特性，这取决于你使用哪种显卡（ADM还是英伟达）。我写过一篇详细的文章，介绍了<a href="http://www.blackmoreops.com/2014/02/11/install-amd-ati-proprietary-driver-fglrx-in-kali-linux-1-0-6-running-kernel-version-3-12-6/">如何在Kali Linux中安装AMD ATI专有驱动程序（fglrx）</a>。</p>
<figure data-type="image" tabindex="8"><a href="http://s4.51cto.com/wyfs02/M00/27/A4/wKioL1N0I1KQufG6AACOljq0ol4768.jpg"><img src="http://s4.51cto.com/wyfs02/M00/27/A4/wKioL1N0I1KQufG6AACOljq0ol4768.jpg" alt="img" loading="lazy"></a></figure>
<p>英伟达用户完全可以遵照安装英伟达驱动程序的<a href="http://docs.kali.org/general-use/install-nvidia-drivers-on-kali-linux">官方说明文档</a>。要是官方说明文档不管用，或者你已无计可施，不妨关注我写过的这另一篇文章：《<a href="http://www.blackmoreops.com/2013/10/20/how-to-install-nvidia-kernel-module-cuda-and-pyrit/">如何手动安装英伟达二进制驱动程序</a>》。</p>
<figure data-type="image" tabindex="9"><a href="http://s5.51cto.com/wyfs02/M02/27/A4/wKiom1N0I5-QfEBhAABIf_rComI556.jpg"><img src="http://s5.51cto.com/wyfs02/M02/27/A4/wKiom1N0I5-QfEBhAABIf_rComI556.jpg" alt="img" loading="lazy"></a></figure>
<p><strong>15. 安装Recordmydesktop和Reminna远程桌面客户端</strong></p>
<p>Recordmydesktop让你能够录制在Kali Linux中的活动，并制作视频。Remmina类似Windows远程桌面客户端。两者都非常实用。可以使用下面这个命令安装它们：</p>
<pre><code>apt-get install gtk-recordmydesktop recordmydesktop remmina -y 
</code></pre>
<p><strong>16. 安装GDebi程序包管理器</strong></p>
<p>dpkg是一个功能强大的工具，但它并不自动安装依赖项。为此，我们需要某种程序包安装工具，以便在安装.deb程序包的同时，可以去获取所有必要的依赖项。眼下最出色的程序包安装工具非gdebi莫属。使用下面这个命令来安装它：</p>
<pre><code>apt-get install gdebi -y 
</code></pre>
<figure data-type="image" tabindex="10"><a href="http://s7.51cto.com/wyfs02/M01/27/A4/wKioL1N0I47SrBAOAAEB_M5IxdQ529.jpg-wh_600x-s_3985124782.jpg"><img src="http://s7.51cto.com/wyfs02/M01/27/A4/wKioL1N0I47SrBAOAAEB_M5IxdQ529.jpg-wh_600x-s_3985124782.jpg" alt="img" loading="lazy"></a></figure>
<p>改进和辅助功能</p>
<p><strong>17. 安装主题</strong></p>
<p>安装主题、美化桌面是个好主意。Kali的默认桌面单调而乏味。你可以使用两种不同的方法来更改主题。</p>
<ul>
<li>手动安装主题</li>
<li>通过PPA软件库安装主题</li>
</ul>
<p><a href="http://www.blackmoreops.com/2014/02/27/change-install-theme-kali-linux-gtk-3-themes/">请阅读此处的细节</a>，即可了解如何在Kali Linux中更改或安装GTK3主题。</p>
<figure data-type="image" tabindex="11"><a href="http://s5.51cto.com/wyfs02/M00/27/A4/wKiom1N0I9Xi8fM0AACYvIEHZfo419.jpg"><img src="http://s5.51cto.com/wyfs02/M00/27/A4/wKiom1N0I9Xi8fM0AACYvIEHZfo419.jpg" alt="img" loading="lazy"></a></figure>
<p><strong>18. 安装一种新的桌面环境（我青睐XFCE）</strong></p>
<p>我青睐XFCE桌面，但你可以试着在Kali Linux中安装/删除不同的桌面环境或窗口管理器。根据你的需要，选择下列链接：</p>
<p>1.《如何在Kali Linux中安装/删除XFCE桌面环境？》，参阅<a href="http://www.blackmoreops.com/2013/10/29/how-to-install-remove-xfce-desktop-environment-in-kali-linux/">http://www.blackmoreops.com/2013/10/29/how-to-install-remove-xfce-desktop-environment-in-kali-linux/</a>。</p>
<p>\2. 《如何在Kali Linux中安装/删除不同的KDE桌面环境？》，参阅<a href="http://www.blackmoreops.com/2013/10/29/how-to-install-remove-different-kde-desktop-environments-in-kali-linux/">http://www.blackmoreops.com/2013/10/29/how-to-install-remove-different-kde-desktop-environments-in-kali-linux/</a>。</p>
<p>\3. 《如何在Kali Linux中安装/删除LXDE桌面环境？》，参阅<a href="http://www.blackmoreops.com/2013/10/29/how-to-install-remove-lxde-desktop-environment-in-kali-linux/">http://www.blackmoreops.com/2013/10/29/how-to-install-remove-lxde-desktop-environment-in-kali-linux/</a>。</p>
<p>\4. 《如何在Kali Linux中安装/删除GNOME桌面环境？》，参阅<a href="http://www.blackmoreops.com/2013/10/29/how-to-install-remove-gnome-desktop-environment-on-kali-linux/">http://www.blackmoreops.com/2013/10/29/how-to-install-remove-gnome-desktop-environment-on-kali-linux/</a>。</p>
<p>\5. 《如何在Kali Linux中安装/删除Cinnamon桌面环境？》，参阅<a href="http://www.blackmoreops.com/2013/10/29/how-to-install-remove-cinnamon-desktop-environment-in-kali-linux/">http://www.blackmoreops.com/2013/10/29/how-to-install-remove-cinnamon-desktop-environment-in-kali-linux/</a>。</p>
<p>\6. 《如何在Kali Linux中安装/删除MATE桌面环境？》，参阅<a href="http://www.blackmoreops.com/2013/10/29/how-to-install-remove-mate-desktop-environment-in-kali-linux/">http://www.blackmoreops.com/2013/10/29/how-to-install-remove-mate-desktop-environment-in-kali-linux/</a>。</p>
<p>最后，遵照这些操作步骤，永久性地<a href="http://www.blackmoreops.com/2013/10/29/permanently-switch-desktop-environments/">更换桌面环境</a>（也就是启动进入到XFCE，而不是GNOME）。</p>
<figure data-type="image" tabindex="12"><a href="http://s6.51cto.com/wyfs02/M02/27/A4/wKioL1N0I8Gjr6zsAACQejk0gHM378.jpg-wh_600x-s_1867495804.jpg"><img src="http://s6.51cto.com/wyfs02/M02/27/A4/wKioL1N0I8Gjr6zsAACQejk0gHM378.jpg-wh_600x-s_1867495804.jpg" alt="img" loading="lazy"></a></figure>
<p><strong>19. 启用自动登录用户</strong></p>
<p>这是个简单的变更。只要打开并编辑名为/etc/gdm3/daemon.conf的文件，假设你在使用GNOME显示管理器（gmd3）作为主要的显示管理器。你可能想要另外也能试一下其他桌面。下面这个链接介绍了《如何在Kali Linux中添加/删除不同的桌面管理器》，详见http://www.blackmoreops.com/2013/10/11/how-to-installremove-different-desktop-environment-or-window-manager-in-kali-linux-1-x/。</p>
<pre><code>root@kali:~# leafpad /etc/gdm3/daemon.conf 
</code></pre>
<p>在daemon即守护程序部分，将用于自动登录的那两行代码取消注释。它最后应该看起来像这样：</p>
<pre><code>[daemon] # Enabling automatic login AutomaticLoginEnable = true AutomaticLogin = root 
</code></pre>
<p>就是这样，容易得很。要是你想知道如何使用不同于root用户的用户，方法如下：</p>
<pre><code>[daemon] # Enabling automatic login AutomaticLoginEnable = true AutomaticLogin = myanotheruser 
</code></pre>
<figure data-type="image" tabindex="13"><a href="http://s1.51cto.com/wyfs02/M01/27/A4/wKiom1N0JBDBe1VvAADDRIbD5CU947.jpg-wh_600x-s_3814205756.jpg"><img src="http://s1.51cto.com/wyfs02/M01/27/A4/wKiom1N0JBDBe1VvAADDRIbD5CU947.jpg-wh_600x-s_3814205756.jpg" alt="img" loading="lazy"></a></figure>
<p>最后但并非最不重要的是，重启系统，核实一下是否管用。（这会管用，因为它是Linux，Kali很出色。）</p>
<pre><code>reboot 
</code></pre>
<p>你可能想要采取进一步行动，或者如果你是KDE用户，那么这里的操作步骤介绍了如何在Kali Linux中，系统启动时，让root用户自动登录（GNOME和KDE），详见http://www.blackmoreops.com/2013/12/19/auto-login-root-user-system-start-kali-linux-gnome-kde/。该文还介绍了如何让不同的非root用户实现自动登录，相当方便。</p>
<p>下面这部分解释了如何更充分地发挥你系统的功能，尤其是发挥显卡的功能。</p>
<p><strong>20. 发掘GPU处理的能力</strong></p>
<p>最后但并非最不重要的是，在你试图破解密码时，GPU处理速度要快得多。你可以选择下面介绍的几种方法，具体取决于所使用的显卡：</p>
<p><em>a. AMD显卡</em></p>
<p>《在Kali Linux 1.x中安装AMD ATI驱动程序（fglrx）》，参阅：<a href="http://www.blackmoreops.com/2013/10/22/install-amd-ati-driver-fglrx-in-kali-linux-1-x/">http://www.blackmoreops.com/2013/10/22/install-amd-ati-driver-fglrx-in-kali-linux-1-x/</a>。</p>
<p>然后参阅其余指南文章：</p>
<ul>
<li>《<a href="http://www.blackmoreops.com/2013/11/22/install-amd-app-sdk-kali-linux/">如何在Kali Linux中安装AMD APP SDK？</a>》</li>
<li>《<a href="http://www.blackmoreops.com/2013/11/22/install-pyrit-in-kali-linux/">如何在Kali Linux中安装Pyrit？</a>》</li>
<li>《<a href="http://www.blackmoreops.com/2013/11/22/install-cal-kali-linux/">如何在Kali Linux中安装CAL++？</a>》</li>
</ul>
<p><em>b. 英伟达显卡</em></p>
<p>英伟达显卡用户完全可以参阅安装英伟达驱动程序的<a href="http://docs.kali.org/general-use/install-nvidia-drivers-on-kali-linux">官方说明文档</a>。如果官方说明文档不管用或者你已无计可施，不妨参阅我写过的另一篇文章，介绍如何手动安装英伟达显卡二进制驱动程序。</p>
<p>《如何在Kali Linux中安装英伟达内核模块Cuda和Pyrit？》，参阅<a href="http://www.blackmoreops.com/2013/10/20/how-to-install-nvidia-kernel-module-cuda-and-pyrit/">http://www.blackmoreops.com/2013/10/20/how-to-install-nvidia-kernel-module-cuda-and-pyrit/</a>。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello Gridea]]></title>
        <id>https://copyer98.github.io/post/hello-gridea/</id>
        <link href="https://copyer98.github.io/post/hello-gridea/">
        </link>
        <updated>2018-12-11T16:00:00.000Z</updated>
        <summary type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
]]></summary>
        <content type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
<!-- more -->
<p><a href="https://github.com/getgridea/gridea">Github</a><br>
<a href="https://gridea.dev/">Gridea 主页</a><br>
<a href="http://fehey.com/">示例网站</a></p>
<h2 id="特性">特性👇</h2>
<p>📝  你可以使用最酷的 <strong>Markdown</strong> 语法，进行快速创作</p>
<p>🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片</p>
<p>🏷️  你可以对文章进行标签分组</p>
<p>📋  你可以自定义菜单，甚至可以创建外部链接菜单</p>
<p>💻  你可以在 <strong>Windows</strong>，<strong>MacOS</strong> 或 <strong>Linux</strong> 设备上使用此客户端</p>
<p>🌎  你可以使用 <strong>𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌</strong> 或 <strong>Coding Pages</strong> 向世界展示，未来将支持更多平台</p>
<p>💬  你可以进行简单的配置，接入 <a href="https://github.com/gitalk/gitalk">Gitalk</a> 或 <a href="https://github.com/SukkaW/DisqusJS">DisqusJS</a> 评论系统</p>
<p>🇬🇧  你可以使用<strong>中文简体</strong>或<strong>英语</strong></p>
<p>🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力</p>
<p>🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步</p>
<p>🌱 当然 <strong>Gridea</strong> 还很年轻，有很多不足，但请相信，它会不停向前 🏃</p>
<p>未来，它一定会成为你离不开的伙伴</p>
<p>尽情发挥你的才华吧！</p>
<p>😘 Enjoy~</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[jQuery ajax方法]]></title>
        <id>https://copyer98.github.io/post/jquery中的ajax方法参数总是记不住，这里记录一下/</id>
        <link href="https://copyer98.github.io/post/jquery中的ajax方法参数总是记不住，这里记录一下/">
        </link>
        <updated>2018-02-27T01:17:00.000Z</updated>
        <summary type="html"><![CDATA[<h1 id="jquery中的ajax方法参数总是记不住这里记录一下">jquery中的ajax方法参数总是记不住，这里记录一下。</h1>
<p>1.url:</p>
<p>要求为String类型的参数，（默认为当前页地址）发送请求的地址。</p>
<p>2.type:<br>
要求为String类型的参数，请求方式（post或get）默认为get。注意其他http请求方法，例如put和delete也可以使用，但仅部分浏览器支持。</p>
<p>3.timeout:<br>
要求为Number类型的参数，设置请求超时时间（毫秒）。此设置将覆盖$.ajaxSetup()方法的全局设置。</p>
<p>4.async:<br>
要求为Boolean类型的参数，默认设置为true，所有请求均为异步请求。如果需要发送同步请求，请将此选项设置为false。注意，同步请求将锁住浏览器，用户其他操作必须等待请求完成才可以执行。</p>
<p>5.cache:<br>
要求为Boolean类型的参数，默认为true（当dataType为script时，默认为false），设置为false将不会从浏览器缓存中加载请求信息。</p>
<p>6.data:<br>
要求为Object或String类型的参数，发送到服务器的数据。如果已经不是字符串，将自动转换为字符串格式。get请求中将附加在url后。防止这种自动转换，可以查看　　processData选项。对象必须为key/value格式，例如<code>{foo1:&quot;bar1&quot;,foo2:&quot;bar2&quot;}</code>转换为<code>&amp;foo1=bar1&amp;foo2=bar2</code>。如果是数组，JQuery将自动为不同值对应同一个名称。例如<code>{foo:[&quot;bar1&quot;,&quot;bar2&quot;]}</code>转换为<code>&amp;foo=bar1&amp;foo=bar2</code>。</p>
<p>7.dataType:<br>
要求为String类型的参数，预期服务器返回的数据类型。如果不指定，JQuery将自动根据http包mime信息返回responseXML或responseText，并作为回调函数参数传递。可用的类型如下：<br>
xml：返回XML文档，可用JQuery处理。<br>
html：返回纯文本HTML信息；包含的script标签会在插入DOM时执行。<br>
script：返回纯文本JavaScript代码。不会自动缓存结果。除非设置了cache参数。注意在远程请求时（不在同一个域下），所有post请求都将转为get请求。<br>
json：返回JSON数据。<br>
jsonp：JSONP格式。使用SONP形式调用函数时，例如<code>myurl?callback=?</code>，JQuery将自动替换后一个“?”为正确的函数名，以执行回调函数。<br>
text：返回纯文本字符串。</p>
<p>8.beforeSend：<br>
要求为Function类型的参数，发送请求前可以修改XMLHttpRequest对象的函数，例如添加自定义HTTP头。在beforeSend中如果返回false可以取消本次ajax请求。XMLHttpRequest对象是惟一的参数。</p>
<pre><code class="language-javascript"> function(XMLHttpRequest) {
        this; //调用本次ajax请求时传递的options参数 
    }
</code></pre>
<p>9.complete：<br>
要求为Function类型的参数，请求完成后调用的回调函数（请求成功或失败时均调用）。参数：XMLHttpRequest对象和一个描述成功请求类型的字符串。</p>
<pre><code class="language-javascript">function(XMLHttpRequest, textStatus) {
        this; //调用本次ajax请求时传递的options参数
    }
</code></pre>
<p>10.success：要求为Function类型的参数，请求成功后调用的回调函数，有两个参数。<br>
​         (1)由服务器返回，并根据dataType参数进行处理后的数据。<br>
​         (2)描述状态的字符串。</p>
<pre><code class="language-javascript">         function(data, textStatus){
            //data可能是xmlDoc、jsonObj、html、text等等
            this;  //调用本次ajax请求时传递的options参数
         }
</code></pre>
<p>11.error:<br>
要求为Function类型的参数，请求失败时被调用的函数。该函数有3个参数，即XMLHttpRequest对象、错误信息、捕获的错误对象(可选)。ajax事件函数如下：</p>
<pre><code class="language-javascript">       function(XMLHttpRequest, textStatus, errorThrown){
          //通常情况下textStatus和errorThrown只有其中一个包含信息
          this;   //调用本次ajax请求时传递的options参数
       }
</code></pre>
]]></summary>
        <content type="html"><![CDATA[<h1 id="jquery中的ajax方法参数总是记不住这里记录一下">jquery中的ajax方法参数总是记不住，这里记录一下。</h1>
<p>1.url:</p>
<p>要求为String类型的参数，（默认为当前页地址）发送请求的地址。</p>
<p>2.type:<br>
要求为String类型的参数，请求方式（post或get）默认为get。注意其他http请求方法，例如put和delete也可以使用，但仅部分浏览器支持。</p>
<p>3.timeout:<br>
要求为Number类型的参数，设置请求超时时间（毫秒）。此设置将覆盖$.ajaxSetup()方法的全局设置。</p>
<p>4.async:<br>
要求为Boolean类型的参数，默认设置为true，所有请求均为异步请求。如果需要发送同步请求，请将此选项设置为false。注意，同步请求将锁住浏览器，用户其他操作必须等待请求完成才可以执行。</p>
<p>5.cache:<br>
要求为Boolean类型的参数，默认为true（当dataType为script时，默认为false），设置为false将不会从浏览器缓存中加载请求信息。</p>
<p>6.data:<br>
要求为Object或String类型的参数，发送到服务器的数据。如果已经不是字符串，将自动转换为字符串格式。get请求中将附加在url后。防止这种自动转换，可以查看　　processData选项。对象必须为key/value格式，例如<code>{foo1:&quot;bar1&quot;,foo2:&quot;bar2&quot;}</code>转换为<code>&amp;foo1=bar1&amp;foo2=bar2</code>。如果是数组，JQuery将自动为不同值对应同一个名称。例如<code>{foo:[&quot;bar1&quot;,&quot;bar2&quot;]}</code>转换为<code>&amp;foo=bar1&amp;foo=bar2</code>。</p>
<p>7.dataType:<br>
要求为String类型的参数，预期服务器返回的数据类型。如果不指定，JQuery将自动根据http包mime信息返回responseXML或responseText，并作为回调函数参数传递。可用的类型如下：<br>
xml：返回XML文档，可用JQuery处理。<br>
html：返回纯文本HTML信息；包含的script标签会在插入DOM时执行。<br>
script：返回纯文本JavaScript代码。不会自动缓存结果。除非设置了cache参数。注意在远程请求时（不在同一个域下），所有post请求都将转为get请求。<br>
json：返回JSON数据。<br>
jsonp：JSONP格式。使用SONP形式调用函数时，例如<code>myurl?callback=?</code>，JQuery将自动替换后一个“?”为正确的函数名，以执行回调函数。<br>
text：返回纯文本字符串。</p>
<p>8.beforeSend：<br>
要求为Function类型的参数，发送请求前可以修改XMLHttpRequest对象的函数，例如添加自定义HTTP头。在beforeSend中如果返回false可以取消本次ajax请求。XMLHttpRequest对象是惟一的参数。</p>
<pre><code class="language-javascript"> function(XMLHttpRequest) {
        this; //调用本次ajax请求时传递的options参数 
    }
</code></pre>
<p>9.complete：<br>
要求为Function类型的参数，请求完成后调用的回调函数（请求成功或失败时均调用）。参数：XMLHttpRequest对象和一个描述成功请求类型的字符串。</p>
<pre><code class="language-javascript">function(XMLHttpRequest, textStatus) {
        this; //调用本次ajax请求时传递的options参数
    }
</code></pre>
<p>10.success：要求为Function类型的参数，请求成功后调用的回调函数，有两个参数。<br>
​         (1)由服务器返回，并根据dataType参数进行处理后的数据。<br>
​         (2)描述状态的字符串。</p>
<pre><code class="language-javascript">         function(data, textStatus){
            //data可能是xmlDoc、jsonObj、html、text等等
            this;  //调用本次ajax请求时传递的options参数
         }
</code></pre>
<p>11.error:<br>
要求为Function类型的参数，请求失败时被调用的函数。该函数有3个参数，即XMLHttpRequest对象、错误信息、捕获的错误对象(可选)。ajax事件函数如下：</p>
<pre><code class="language-javascript">       function(XMLHttpRequest, textStatus, errorThrown){
          //通常情况下textStatus和errorThrown只有其中一个包含信息
          this;   //调用本次ajax请求时传递的options参数
       }
</code></pre>
<!--more-->
<p>12.contentType：<br>
要求为String类型的参数，当发送信息至服务器时，内容编码类型默认为&quot;application/x-www-form-urlencoded&quot;。该默认值适合大多数应用场合。</p>
<p>13.dataFilter：<br>
要求为Function类型的参数，给Ajax返回的原始数据进行预处理的函数。提供data和type两个参数。data是Ajax返回的原始数据，type是调用jQuery.ajax时提供的dataType参数。函数返回的值将由jQuery进一步处理。<br>
​</p>
<pre><code class="language-javascript">           function(data, type){
                //返回处理后的数据
                return data;
            }
</code></pre>
<p>14.dataFilter：<br>
要求为Function类型的参数，给Ajax返回的原始数据进行预处理的函数。提供data和type两个参数。data是Ajax返回的原始数据，type是调用jQuery.ajax时提供的dataType参数。函数返回的值将由jQuery进一步处理。</p>
<pre><code class="language-javascript"> function(data, type) {
        //返回处理后的数据
        return data;
    }
</code></pre>
<p>15.global：<br>
要求为Boolean类型的参数，默认为true。表示是否触发全局ajax事件。设置为false将不会触发全局ajax事件，ajaxStart或ajaxStop可用于控制各种ajax事件。</p>
<p>16.ifModified：<br>
要求为Boolean类型的参数，默认为false。仅在服务器数据改变时获取新数据。服务器数据改变判断的依据是Last-Modified头信息。默认值是false，即忽略头信息。</p>
<p>17.jsonp：<br>
要求为String类型的参数，在一个jsonp请求中重写回调函数的名字。该值用来替代在&quot;callback=?&quot;这种GET或POST请求中URL参数里的&quot;callback&quot;部分，例如{jsonp:'onJsonPLoad'}会导致将&quot;onJsonPLoad=?&quot;传给服务器。</p>
<p>18.username：<br>
要求为String类型的参数，用于响应HTTP访问认证请求的用户名。</p>
<p>19.password：<br>
要求为String类型的参数，用于响应HTTP访问认证请求的密码。</p>
<p>20.processData：<br>
要求为Boolean类型的参数，默认为true。默认情况下，发送的数据将被转换为对象（从技术角度来讲并非字符串）以配合默认内容类型&quot;application/x-www-form-urlencoded&quot;。如果要发送DOM树信息或者其他不希望转换的信息，请设置为false。</p>
<p>21.scriptCharset：<br>
要求为String类型的参数，只有当请求时dataType为&quot;jsonp&quot;或者&quot;script&quot;，并且type是GET时才会用于强制修改字符集(charset)。通常在本地和远程的内容编码不同时使用。</p>
<p>案例代码：</p>
<pre><code class="language-javascript">$(function(){
    $('#send').click(function(){
         $.ajax({
             type: &quot;GET&quot;,
             url: &quot;test.json&quot;,
             data: {username:$(&quot;#username&quot;).val(), content:$(&quot;#content&quot;).val()},
             dataType: &quot;json&quot;,
             success: function(data){
                         $('#resText').empty();   //清空resText里面的所有内容
                         var html = ''; 
                         $.each(data, function(commentIndex, comment){
                               html += '&lt;div class=&quot;comment&quot;&gt;&lt;h6&gt;' + comment['username']
                                         \+ ':&lt;/h6&gt;&lt;p class=&quot;para&quot;' + comment['content']
                                         \+ '&lt;/p&gt;&lt;/div&gt;';
                         });
                         $('#resText').html(html);
                      }
         });
    });
});
</code></pre>
<p>$.ajax验证登录：</p>
<pre><code>  &lt;script type=&quot;text/javascript&quot; language=&quot;javascript&quot;&gt;
        function IbtnEnter_onclick() {
            checklogin();
            return false;
        }
        function checklogin() {
            if ($(&quot;#TxtUserName&quot;).val() == &quot;&quot;) {
                alert(&quot;用户名不能为空！&quot;);
                $(&quot;#TxtUserName&quot;).focus();
                return false;
            }
            if ($(&quot;#TxtPassword&quot;).val() == &quot;&quot;) {
                alert(&quot;密码不能为空！&quot;);
                $(&quot;#TxtPassword&quot;).focus();
                return false;
            }
            $.ajax({
                type: &quot;POST&quot;,
                url: &quot;ajax/Handler.ashx?M=&quot; + Math.random(),
                data: &quot;username=&quot; + $(&quot;#TxtUserName&quot;).val().toString() + &quot;&amp;pwd=&quot; + $(&quot;#TxtPassword&quot;).val().toString(),
                success: function (data) {
                    if (data == &quot;1&quot;) {
                        location.href = &quot;index.aspx&quot;;
                        return true;
                    }
                    else {
                        alert(&quot;请确认您输入的用户名或密码输入是否正确！&quot;);
                        $(&quot;#TxtUserName&quot;).val(&quot;&quot;);
                        $(&quot;#TxtPassword&quot;).val(&quot;&quot;);
                        $(&quot;#TxtUserName&quot;).focus();
                        return false;
                    }
                }

            })
        }
    &lt;/script&gt;


一般处理程序

&lt;%@ WebHandler Language=&quot;C#&quot; Class=&quot;Handler&quot; %&gt;

using System;
using System.Web;
using System.Data.SqlClient;
using System.Web.SessionState;//继承接口IReadOnlySessionState需要引入的命名空间

public class Handler : IHttpHandler, IRequiresSessionState
{
    SqlHelper helper = new SqlHelper();
    public void ProcessRequest(HttpContext context)
    {
        context.Response.ContentType = &quot;text/plain&quot;;

        string username = context.Request.Params[&quot;username&quot;].ToString().Trim();
        string pwd = context.Request.Params[&quot;pwd&quot;].ToString().Trim();
        if (username != &quot;&quot; &amp;&amp; pwd != &quot;&quot;)
        {

            string sql = @&quot;SELECT * FROM [USER] WHERE USERNAME='&quot;+username+&quot;' AND PASSWORD='&quot;+pwd+&quot;' &quot;;
            if (!helper.Exists(sql))
            {
                context.Response.Write(&quot;0&quot;);
            }

            else
            {
                SqlDataReader reader = helper.ExecuteReader(sql);
                while (reader.Read())
                {
                    context.Response.Write(&quot;1&quot;);
                    context.Session[&quot;username&quot;] = username.ToString().Trim();
                    context.Session[&quot;pwd&quot;] = pwd.ToString().Trim();
                }
            }
            
        }
    }
 
    public bool IsReusable
    {
        get
        {
            return false;
        }
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[js开发工具大全]]></title>
        <id>https://copyer98.github.io/post/js开发工具大全/</id>
        <link href="https://copyer98.github.io/post/js开发工具大全/">
        </link>
        <updated>2017-12-26T07:17:00.000Z</updated>
        <summary type="html"><![CDATA[<p>标签: js,前端</p>
<h2 id="js-开发工具">js 开发工具</h2>
<h1 id="javascript-开发工具大全">JavaScript 开发工具大全</h1>
<p><strong>为了保证可读性，本文采用意译而非直译。另外，本文版权归原作者所有，翻译仅用于学习</strong>。</p>
<p>简介</p>
<p>2017 年 1 月，Stack Overflow 年度开发者调研一共访问了<strong>64000</strong>个程序员，发现 JavaScript 已经连续 5 年成为最流行的编程语言。</p>
<figure data-type="image" tabindex="1"><img src="http://p3.pstatp.com/large/28940003357c94954144" alt="JavaScript开发工具大全" loading="lazy"></figure>
<p>这篇博客将介绍一些常用的 JavaScript 开发工具：</p>
<ul>
<li>构建&amp;自动化</li>
<li>IDE&amp;编辑器</li>
<li>文档</li>
<li>测试</li>
<li>调试</li>
<li>安全</li>
<li>代码优化&amp;分析</li>
<li>包管理</li>
</ul>
]]></summary>
        <content type="html"><![CDATA[<p>标签: js,前端</p>
<h2 id="js-开发工具">js 开发工具</h2>
<h1 id="javascript-开发工具大全">JavaScript 开发工具大全</h1>
<p><strong>为了保证可读性，本文采用意译而非直译。另外，本文版权归原作者所有，翻译仅用于学习</strong>。</p>
<p>简介</p>
<p>2017 年 1 月，Stack Overflow 年度开发者调研一共访问了<strong>64000</strong>个程序员，发现 JavaScript 已经连续 5 年成为最流行的编程语言。</p>
<figure data-type="image" tabindex="1"><img src="http://p3.pstatp.com/large/28940003357c94954144" alt="JavaScript开发工具大全" loading="lazy"></figure>
<p>这篇博客将介绍一些常用的 JavaScript 开发工具：</p>
<ul>
<li>构建&amp;自动化</li>
<li>IDE&amp;编辑器</li>
<li>文档</li>
<li>测试</li>
<li>调试</li>
<li>安全</li>
<li>代码优化&amp;分析</li>
<li>包管理</li>
</ul>
<!--more-->
<p>构建 &amp; 自动化</p>
<ul>
<li><strong>Webpack</strong>对 JavaScript 应用依赖的所有模块进行静态分析，生成依赖图，然后将它们打包成数个静态文件。</li>
<li><strong>Grunt</strong>以将重复耗时的任务自动化。Grunt 的生态系统非常大，有超过 6010 个插件。</li>
<li><strong>Gulp</strong>发布于 Grunt 之后，采用了完全不同的方式，使用 JavaScript 函数定义任务。它有超过 2770 个插件，并且提供了更好的控制。</li>
<li><strong>Browserify</strong>使得开发者可以在浏览器使用<strong>CommonJS 模块</strong>。开发者像在 node 环境一样，通过<code>require('modules')</code>来组织模块之间的引用和依赖，Browserify 将这些依赖打包成浏览器可以直接引用的 JS 文件。</li>
<li><strong>Brunch</strong>非常简单，速度很快。Brunch 的配置文件非常简单，入门文档非常详细。Brunch 会自动生成 Source Map，方便了开发者 Debug。</li>
<li><strong>Yeoman</strong>可以用于任何编程语言(JavaScript, Python, C#, Java, etc.)。它是前端开发的脚手架，有 6213 个插件。</li>
</ul>
<p>IDE &amp; 编辑器</p>
<ul>
<li><strong>WebStorm</strong>是一款强大的 JavaScript IDE。它支持多种框架和 CSS 语言，包括前端，后端，移动端以及桌面应用。WebStorm 可以无缝整合第三方工具，例如构建构建、语法检查构建 linter 等等。它提供了代码补全，实时错误监测，导航，内置控制台，各种插件等一系统功能。</li>
<li><strong>Atom</strong>是 GitHub 团队开发的。开发者可以很容易地对 Atom 进行自定义。Atom 自带了一个包管理工具，代码补全，文件系统浏览器，支持多个平台以及其他有用的功能。</li>
<li><strong>Visual Studio Code</strong>是微软开发的 IDE，支持 TypeScript。它提供了代码补全，语法高亮，支持 Git 命令等等。另外，它还有非常多的插件。</li>
<li><strong>Brackets</strong>是一个轻量级的开源编辑器。它专注于可视化工具，可以帮助开发者开发 Web 应用。Brackets 支持实时预览以及行内编辑。</li>
</ul>
<p>文档</p>
<ul>
<li><strong>Swagger</strong>提供了一系列规则用于描述 API。使用 Swagger，可以创建清晰的文档，并且自动化 API 相关的操作(例如功能测试)。</li>
<li><strong>JSDoc</strong>可以根据 javascript 文件中注释信息，生成 JavaScript 应用程序或库、模块的 API 文档。JSDoc 可以用于管理大型项目。</li>
<li>**jGrouseDoc **是一个开源工具，可根据 JavaScript 注释生成类似 Jaavdoc 的源码文档。它不仅可以为变量和函数生成文档，还可以为模块等其他元素生成文档。</li>
<li><strong>YUIDoc</strong>基于 Nodejs，可以将文档中的注释生成 API 文档。它使用类似于 Javadoc 与 Doxygen 的语法，并且支持实时预览，支持各种语言，并且支持标记语言。</li>
<li>**Docco **是免费的文档工具，由 Literate CoffeeScript 编写。它将代码中的注释生成 HTML 文档。Docco 并不限于 JavaScript，同时支持 Python, Ruby, Clojure 等语言。</li>
</ul>
<p>测试</p>
<ul>
<li><strong>Jasmine</strong>是一个行为驱动开发(BDD)框架，用于测试 JavaScript 代码。它不依赖任何第三方模块，也不需要 DOM。它的语法非常简单易懂，使得编写测试变得很简单。另外，它也可以用于测试 Node.js，Python 以及 Ruby。</li>
<li><strong>Mocha</strong>是一个功能测试框架，用于测试 Node.js 以及浏览器端 JavaScript。作为开发者首选的测试框架，它可以自由的编写测试组，提供详细的测试报告，同时让异步测试非常简单。Mocha 通常与断言库<strong>Chai</strong>来验证测试结果。</li>
<li><strong>PhantomJS</strong>用于前端单元测试。由于 PhantomJS 是一个无界面的 Webkit 浏览器引擎，与直接使用浏览器测试相比，使用 PhantomJS 脚本可以运行得更快。它支持各种网页标准，例如 JSON, Canvas, DOM 操作, SVG 以及 CSS 选择器。</li>
<li><strong>Protractor</strong>是一个端到端测试框架，用于测试 Angular 应用。它是基于 WebDriverJS 构建的，它可以通过浏览器事件或者原生事件，从而模拟真实用户，来测试应用。</li>
</ul>
<p>调试</p>
<ul>
<li><strong>JavaScript Debugger</strong>由 Mozilla Developer Network (MDN)开发，可以独立用于调试 Node.js 代码，或者用于其他浏览器。Firefox 提供了本地和远程调试功能，并且，Firefox 安卓端也用于调试运行在安卓应用。</li>
<li><strong>Chrome Dev Tools</strong>提供了一系列工具，可以用于调试 JavaScript 代码，编辑 CSS，以及测试应用性能。</li>
<li><strong>ng-inspector</strong>是 Firefox，Chrome 和 Safari 浏览器插件，可以帮助开发者开发、理解以及调试 AngularJS 应用。它提供了实时更新，DOM 高亮等功能。</li>
<li><strong>Augury</strong>是一个 Chrome 插件，可以用于调试 Angular 2 应用。它让开发者可以直接查看应用结构，操作特征以及状态变化。</li>
</ul>
<p>安全</p>
<ul>
<li><strong>Snyk</strong>是一个付费服务，用于发现、修复和预防 JavaScript，Node.js 和 Ruby 应用的已知漏洞。Snyk 拥有自己的漏洞库，以及 NSP 和 NIST NVD 的漏洞数据。它允许开发者使用它们的补丁和更新来修复这些安全漏洞。</li>
<li><strong>Node Security Project</strong>提供了工具用于扫描依赖来监测漏洞。NSP 使用自己的漏洞数据，以及来自 NIST NVD 的漏洞数据。NSP 支持集成 GitHub 和 CI 软件，实时监测和报警，并且可以提供如何修复 Node.js 应用漏洞的建议。</li>
<li><strong>RetireJS</strong>是一个开源的依赖监测工具。它包含了多个组件，包括命令行工具，Grunt 插件，Firefox 和 Chrome 插件，Burp 和 OWASP ZAP 插件。Retirejs 从 NIST NVD，漏洞追踪系统，博客和邮件列表等手机漏洞数据。</li>
<li><strong>Gemnasium</strong>是一个付费工具，不过有免费方案。它支持各种技术，比如 Ruby, PHP, Bower, Python 和 npm。Gemnasium 提供很多非常有用的特性，比如自动更新，实时报警以及 Slack 集成等。</li>
<li><strong>OSSIndex</strong>支持多个生态系统(Java, JavaScript 和.NET/C#)，以及多个平台，例如 NuGet, npm, Bower, Chocolatey, Maven, Composer, Drupal 和 MSI。它从 NVD 以及其他来源收集漏洞数据。</li>
</ul>
<p>代码优化 &amp; 分析</p>
<ul>
<li><strong>JSLint</strong>是一个 Web 服务，用于验证 JavaScript 的代码质量。当它诊断到一个问题时，它会返回问题的大致位置和出错信息。JSLint 可以分析一些编码规范以及语法错误。</li>
<li><strong>JSHint</strong>可以发现 JavaScript 中的错误以及一些潜在的问题。JSHint 是一个静态代码分析工具，旨在帮助开发者编写大型的程序。它可以诊断语法错误、隐形类型转换等问题，但是它并不能确定你的应用是否正确、性能是否足够好、以及是否会发生内存泄漏。 JSHint 是 JSLint 的一个 fork。</li>
<li><strong>ESLint</strong>是一个开源诊断工具，用于 JSX 和 JavaScript 应用。它可以帮助开发者发现可疑的或者不符合特定编程规范的代码。它帮助开发者在没有执行代码之前发现 JS 代码中问题，节省了不少时间。ESLint 由 Node.js 编写，可以使用 NPM 安装。</li>
<li><strong>Flow</strong>是 JavaScript 代码静态类型检测器，由 Facebook 开发。Flow 可以在编码时检查到类型错误并做出提示。</li>
</ul>
<p>包管理</p>
<ul>
<li><strong>Bower</strong>是一个用于管理前端依赖的包管理器，Twitter 创建。它提供了大量可供使用的依赖包，帮助 JavaScript 开发者更方便地管理前端依赖的 JS 库。</li>
<li><strong>NPM</strong>是<strong>node package manager</strong>的缩写，事实上 NPM 包可以用于前后端。它是 JavaScript 包管理系统，也是世界上最大的依赖库，有超过 475,000 个模块。</li>
<li><strong>Yarn</strong>是 Facebook, Google, Exponent 和 Tilde 开发的一款新的 JavaScript 包管理工具。与 NPM 相比，它解决了安全、性能以及一致性问题。</li>
<li><strong>Duo</strong>吸取了 Component, Browserify 和 Go 的经验，致力于简化大型 Web 应用的构建过程。</li>
</ul>
<p>原文: THE ULTIMATE LIST OF JAVASCRIPT TOOLS</p>
<p>译者: Fundebug</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[linux基本知识]]></title>
        <id>https://copyer98.github.io/post/linux基本知识/</id>
        <link href="https://copyer98.github.io/post/linux基本知识/">
        </link>
        <updated>2017-12-18T01:17:00.000Z</updated>
        <summary type="html"><![CDATA[<p>标签： linux</p>
<p>Linux 的命令行</p>
<h2 id="第一章">第一章</h2>
<p>安装桌面环境: login 进入系统之后，开始进行用户界面的安装。首先输入如下命令：<br>
<code>sudo apt-get install xinit</code><br>
上述安装完毕之后，再安装环境管理器。本人亲测安装的是 GNOME。使用如下命令安装：<br>
<code>sudo apt-get install gdm</code><br>
然后，安装桌面环境。</p>
]]></summary>
        <content type="html"><![CDATA[<p>标签： linux</p>
<p>Linux 的命令行</p>
<h2 id="第一章">第一章</h2>
<p>安装桌面环境: login 进入系统之后，开始进行用户界面的安装。首先输入如下命令：<br>
<code>sudo apt-get install xinit</code><br>
上述安装完毕之后，再安装环境管理器。本人亲测安装的是 GNOME。使用如下命令安装：<br>
<code>sudo apt-get install gdm</code><br>
然后，安装桌面环境。</p>
<!--more-->
<p>本人亲测安装的是 KUbuntu。安装命令如下：</p>
<p><code>sudo apt-get install kubuntu-desktop</code><br>
<code>sudo apt-get install gnome-session-fallback</code></p>
<p>或者：</p>
<p><code>sudo apt-get install gnome-panel</code><br>
。安装时的界面如下所示</p>
<p>安装中文语言包<br>
<code>sudo apt-get install language-pack-zh-han*</code></p>
<p>安装 gnome 包<br>
<code>sudo apt-get install language-pack-gnome-zh-han*</code></p>
<p>安装 kde 包<br>
<code>sudo apt-get install language-pack-kde-zh-han*</code><br>
到这里就能够查看目录下面的中文字符了。</p>
<p>最后运行语言支持检查<br>
<code>sudo apt install $(check-language-support)</code><br>
会更新最新的语言支持包设置语言:改英文: 用 vi(或 nano 等文本编辑器)打开 /etc/default/locale 文件将原来的配置内容修改为<br>
LANG=”en_US.UTF-8″<br>
LANGUAGE=”en_US:en”<br>
再在终端下运行：<br>
<code>locale-gen -en_US:en</code><br>
注销或重启后，即可恢复为英文的语言环境。改为中文:<br>
1、修改／etc/default/locale<br>
如不存在则新建一个如下：</p>
<blockquote>
<p>LANG='en_US' #中文可以用 zh_CN<br>
LANGUAGE='en_US:en' #中文可以用 zh_CN:zh</p>
</blockquote>
<p>2、reboot 即可<br>
locale 命令可以列出当前系统所用的所有语言设置</p>
<pre><code>Sudo apt install
Sudo apt install
sudo apt
</code></pre>
<p>apt 1.4 (amd64)<br>
用法： apt [选项] 命令</p>
<p>命令行软件包管理器 apt 提供软件包搜索，管理和信息查询等功能。它提供的功能与其他 APT 工具相同（像 apt-get 和 apt-cache），但是默认情况下被设置得更适合交互。</p>
<p>常用命令：</p>
<pre><code>  list - 根据名称列出软件包
  search - 搜索软件包描述
  show - 显示软件包细节
  install - 安装软件包
  remove - 移除软件包
  autoremove - 卸载所有自动安装且不再使用的软件包
  update - 更新可用软件包列表
  upgrade - 通过 安装/升级 软件来更新系统
  full-upgrade - 通过 卸载/安装/升级 来更新系统
  edit-sources - 编辑软件源信息文件
</code></pre>
<p>参见 apt(8) 以获取更多关于可用命令的信息。程序配置选项及语法都已经在 apt.conf(5) 中阐明。欲知如何配置软件源，请参阅 sources.list(5)。软件包及其版本偏好可以通过 apt_preferences(5) 来设置。关于安全方面的细节可以参考 apt-secure(8).<br>
本 APT 具有超级牛力。</p>
<p><img src="https://i.imgur.com/Ns68ca3.png" alt="" loading="lazy"><br>
好玩的软件 oneko,cmatrix,</p>
<p>软件安装,</p>
<pre><code>gdebi ,gedit ,cinnamon ,mate,xfce,unity,gnome-fontviewer,或者 font-manager,gnome-ternimal,firefox,screefetch,file-roller(压缩包管理器),tree,transmission(迅雷),gnome-software 软件更新器,gnome-packagekit 软件包 unbuntu-desktop, Software-properties-gtk(软件源,ppa 更新) Gnome-software (软件商店) Gnome-systemmoniter(任务管理器) FTP/SFTP 客户端: 声音视频:audacity,vlc,rhythmbox 图像处理:gimp 抓图工具:shutter gnome-web-photo Mypaint,darktable,inkscape,dia,shotwell, 录屏工具:gek-recordmydesktop 视频后期处理:openshot
</code></pre>
<p>搜狗输入法安装,安装 gdebi<br>
进入搜狗输入法目录输入命令行: <code>sudo gdebi sogoupinyin_2.1.0.0086_amd64.deb</code><br>
安装 cinnamon :<code>sudo apt install cinnamon</code><br>
然后运行<code>cinnamon –replace</code><br>
运行图形化命令,gksu<br>
Filezilla:<code>sudo aptitude install –y filezilla</code></p>
<p>安装主题:</p>
<ol>
<li>elementary os 的主题</li>
</ol>
<pre><code>sudo add-apt-repository ppa:elementary-os/daily
sudo apt-get update
sudo apt-get install elementary-icon-theme
</code></pre>
<ol start="2">
<li>ubuntukylin ukui 主题, www.ukui.org 官网教程安装这个就好</li>
<li>zorinos 主题安装方法，首先打开终端输入以下命令安装主题：</li>
</ol>
<pre><code>sudo add-apt-repository ppa:noobslab/themes
sudo apt-get update
sudo apt-get install zorinos-themes
</code></pre>
<p>在终端输入以下命令安装图标主题：</p>
<pre><code>sudo add-apt-repository ppa:noobslab/icons2
sudo apt-get update
sudo apt-get install zorinos-icons
</code></pre>
<p>安装或使用调节工具：如 Unity Tweak Tool、Gnome-tweak-tool 或者 Ubuntu-Tweak 来启用主题和图标。</p>
<h2 id="第二章-linux-的文件系统">第二章 linux 的文件系统</h2>
<p>Lib 各种动态链接库存放的位置,类似 windows 的 dll 文件,只不过 linux 的是.so 文件,<br>
<img src="https://i.imgur.com/lWVyBIM.png" alt="" loading="lazy"></p>
<pre><code>```

```
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[linux桌面环境]]></title>
        <id>https://copyer98.github.io/post/linux安装桌面环境/</id>
        <link href="https://copyer98.github.io/post/linux安装桌面环境/">
        </link>
        <updated>2017-12-16T01:17:00.000Z</updated>
        <summary type="html"><![CDATA[<h1 id="linux-桌面环境">linux 桌面环境</h1>
<p>标签： linux 使用</p>
<hr>
<h2 id="ubuntu-和她的衍生">ubuntu 和她的衍生</h2>
<ol>
<li>首先，ubuntu server 版本的安装这里就不再赘述，基本的还是三个步骤，首先是下载镜像，然后使用 ultraISO 刻录至 u 盘，最后通过 U 盘引导进行安装。安装过程中，会要求你输入用户名和密码，一定要牢记，因为后续软件的安装都需要密码。</li>
<li>然后，login 进入系统之后，开始进行用户界面的安装。首先输入如下命令：<br>
<code>sudo apt-get install xinit</code></li>
<li>上述安装完毕之后，再安装环境管理器。本人亲测安装的是 GNOME。使用如下命令安装：<br>
<code>sudo apt-get install gdm</code></li>
</ol>
]]></summary>
        <content type="html"><![CDATA[<h1 id="linux-桌面环境">linux 桌面环境</h1>
<p>标签： linux 使用</p>
<hr>
<h2 id="ubuntu-和她的衍生">ubuntu 和她的衍生</h2>
<ol>
<li>首先，ubuntu server 版本的安装这里就不再赘述，基本的还是三个步骤，首先是下载镜像，然后使用 ultraISO 刻录至 u 盘，最后通过 U 盘引导进行安装。安装过程中，会要求你输入用户名和密码，一定要牢记，因为后续软件的安装都需要密码。</li>
<li>然后，login 进入系统之后，开始进行用户界面的安装。首先输入如下命令：<br>
<code>sudo apt-get install xinit</code></li>
<li>上述安装完毕之后，再安装环境管理器。本人亲测安装的是 GNOME。使用如下命令安装：<br>
<code>sudo apt-get install gdm</code></li>
</ol>
<!--more-->
<ol start="4">
<li>然后，安装桌面环境。本人亲测安装的是 KUbuntu。安装命令如下：<br>
<code>sudo apt-get install kubuntu-desktop</code></li>
</ol>
<h2 id="centos">centos</h2>
<p>1、首先安装X(X Window System),命令为<br>
<code>yum groupinstall &quot;X Window System&quot;</code> 回车（注意有引号）</p>
<p>2、由于这个软件组比较大，安装过程会比较慢，安装完成会出现complete！</p>
<p>3、检查一下我们已经安装的软件以及可以安装的软件，用命令<br>
<code>yum grouplist</code> 回车</p>
<p>4、然后安装我们需要的图形界面软件，GNOME(GNOME Desktop)<br>
这里需要特别注意！！！！<br>
一定要注意 名称必须对应 不同版本的centOS的软件名可能不同 其他Linux系统类似<br>
否则会出现<code>No packages in any requested group available to install or update</code> 的错误。<br>
5、同样的。<br>
由于这个软件组比第一个要大很多（包含700个左右的软件），安装过程会很慢，请耐心等待。安装完成会出现complete！</p>
<p>6、安装完成后我们可以通过命令 startx 进入图形界面，第一次进入会比较慢，请耐心等待。（可能需要重启，命令为reboot）<br>
如果启动正常的话，到这里就可以不用继续向下看了，如果出现问题，那么请继续看。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[node配置]]></title>
        <id>https://copyer98.github.io/post/node设置/</id>
        <link href="https://copyer98.github.io/post/node设置/">
        </link>
        <updated>2017-12-10T01:17:00.000Z</updated>
        <summary type="html"><![CDATA[<p>标签： 插件</p>
<h1 id="淘宝-npm-地址httpnpmtaobaoorg">淘宝 npm 地址：http://npm.taobao.org/</h1>
<p><strong>如何使用</strong></p>
<blockquote>
<p>有很多方法来配置 npm 的 registry 地址，下面根据不同情境列出几种比较常用的方法<br>
。以淘宝 npm 镜像举例：</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<p>标签： 插件</p>
<h1 id="淘宝-npm-地址httpnpmtaobaoorg">淘宝 npm 地址：http://npm.taobao.org/</h1>
<p><strong>如何使用</strong></p>
<blockquote>
<p>有很多方法来配置 npm 的 registry 地址，下面根据不同情境列出几种比较常用的方法<br>
。以淘宝 npm 镜像举例：</p>
</blockquote>
<!--more-->
<h2 id="1-临时使用">1. 临时使用</h2>
<blockquote>
<p>npm --registry https://registry.npm.taobao.org install express</p>
</blockquote>
<h2 id="2-持久使用">2. 持久使用</h2>
<blockquote>
<p>npm config set registry https://registry.npm.taobao.org</p>
</blockquote>
<p>配置后可通过下面方式来验证是否成功</p>
<blockquote>
<p>npm config get registry</p>
</blockquote>
<blockquote>
<p>npm info express</p>
</blockquote>
<h2 id="3-通过-cnpm-使用">3. 通过 cnpm 使用</h2>
<blockquote>
<p>npm install -g cnpm --registry=https://registry.npm.taobao.org</p>
</blockquote>
<p>使用</p>
<blockquote>
<p>cnpm install express</p>
</blockquote>
<p>首先打开命令行终端 , 然后输入</p>
<blockquote>
<p>npm config ls</p>
</blockquote>
<p>这时你应该可以看到一个 prefix 属性 , 它表明了 npm 包的默认安装位置 , 因此可以通<br>
过改这个配置修改包安装位置 . 具体的命令如下 :</p>
<blockquote>
<p>npm config set prefix &quot;your node_global path&quot;</p>
</blockquote>
<p>把引号内的内容改为你所希望的路径即可 . 比如我 :</p>
<blockquote>
<p>npm config ls;</p>
</blockquote>
<blockquote>
<p>npm config set prefix &quot;D:\configuration\nodeconfig\npm&quot;</p>
</blockquote>
<blockquote>
<p>npm config set cache &quot;D:\configuration\nodeconfig\npm-cache&quot;</p>
</blockquote>
]]></content>
    </entry>
</feed>