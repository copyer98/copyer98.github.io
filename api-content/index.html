{"posts":[{"title":"java教程","content":"java教程 标签： 干货 springboot学习指南 JavaGuide (gitee.io) Introduction · Thinking in Java (Java 编程思想) (quanke.name) fullstack tutorial - 全栈开发指南 (frank-lam.github.io) CS-Notes (cyc2018.github.io) Java工程师成神之路 (gitee.io) ","link":"https://copyer98.github.io/post/java教程/"},{"title":"Vue-渐进式JavaScript框架","content":"正在更新中... Vue -渐进式JavaScript框架 介绍 vue2官网 (vue3在这里) vue-rotuer官网 vuex官网 vue调试工具(必装,需要科学上网) vue组件大全 vue-cli开发工具 vite开发工具 vue-ssr官网 nuxtjs官网(实现vuessr,快速搭建平台) Vue.js 是一套构建用户界面(UI)的渐进式JavaScript框架 学习Vue要转化思想 不要在想着怎么操作DOM(jquery思想)，而是想着如何操作数据！！！ 起步 - Hello Vue 使用vue-cli工具 安装：npm i -g @vue/cli vue-cli是什么? Vue CLI 是一个基于 Vue.js 进行快速开发的完整系统，提供： 通过 @vue/cli 搭建交互式的项目脚手架。 通过 @vue/cli + @vue/cli-service-global 快速开始零配置原型开发。 一个运行时依赖 (@vue/cli-service)，该依赖： 可升级； 基于 webpack 构建，并带有合理的默认配置； 可以通过项目内的配置文件进行配置； 可以通过插件进行扩展。 一个丰富的官方插件集合，集成了前端生态中最好的工具。 一套完全图形化的创建和管理 Vue.js 项目的用户界面。 如何使用? //创建一个项目 vue create your-app //之后按照提示来就可以 vue ui //使用可视化界面配置项目 使用vite开发 Vite 是一个 web 开发构建工具，由于其原生 ES 模块导入方式，可以实现闪电般的冷服务器启动。 通过在终端中运行以下命令，可以使用 Vite 快速构建 Vue 项目。 使用 npm： npm init @vitejs/app &lt;project-name&gt; cd &lt;project-name&gt; npm install npm run dev 或者 yarn： yarn create @vitejs/app &lt;project-name&gt; cd &lt;project-name&gt; yarn yarn dev 但是对于vue2需要一个插件,需要在根目录添加一个vite.config.js,并使用插件vite-plugin-vue2(需要自己研究配置) const { createVuePlugin } = require('vite-plugin-vue2'); module.exports = { plugins: [createVuePlugin()], }; 创建一个hellowold程序 &lt;!-- 指定vue管理内容区域，需要通过vue展示的内容都要放到找个元素中 通常我们也把它叫做边界 数据只在边界内部解析--&gt; &lt;div id=&quot;app&quot;&gt;{{ msg }}&lt;/div&gt; &lt;!-- 引入 vue.js --&gt; &lt;script src=&quot;vue.js&quot;&gt;&lt;/script&gt; &lt;!-- 使用 vue --&gt; &lt;script&gt; var vm = new Vue({ // el：提供一个在页面上已存在的 DOM 元素作为 Vue 实例的挂载目标 el: '#app', // Vue 实例的数据对象，用于给 View 提供数据 data: { msg: 'Hello Vue' } }) &lt;/script&gt; Vue实例 注意 1：先在data中声明数据，再使用数据 注意 2：可以通过 vm.$data 访问到data中的所有属性，或者 vm.msg var vm = new Vue({ data: { msg: '大家好，...' } }) vm.$data.msg === vm.msg // true 数据绑定 最常用的方式：Mustache(插值语法)，也就是 {{}} 语法 解释：{{}}从数据对象data中获取数据 说明：数据对象的属性值发生了改变，插值处的内容都会更新 说明：{{}}中只能出现JavaScript表达式 而不能解析js语句 注意：Mustache 语法不能作用在 HTML 元素的属性上 &lt;h1&gt;Hello, {{ msg }}.&lt;/h1&gt; &lt;p&gt;{{ 1 + 2 }}&lt;/p&gt; &lt;p&gt;{{ isOk ? 'yes': 'no' }}&lt;/p&gt; &lt;!-- ！！！错误示范！！！ --&gt; &lt;h1 title=&quot;{{ err }}&quot;&gt;&lt;/h1&gt; 双向数据绑定 Vue two way data binding 双向数据绑定：将DOM与Vue实例的data数据绑定到一起，彼此之间相互影响 数据的改变会引起DOM的改变 DOM的改变也会引起数据的变化 原理：Object.defineProperty中的get和set方法 getter和setter：访问器 作用：指定读取或设置对象属性值的时候，执行的操作 Vue - 深入响应式原理 MDN - Object.defineProperty() /* defineProperty语法 介绍 */ var obj = {} Object.defineProperty(obj, 'msg', { // 设置 obj.msg = &quot;1&quot; 时set方法会被系统调用 参数分别是设置后和设置前的值 set: function (newVal, oldVal) { }, // 读取 obj.msg 时get方法会被系统调用 get: function ( newVal, oldVal ) {} }) Vue双向绑定的极简实现 剖析Vue原理&amp;实现双向绑定MVVM &lt;!-- 示例 --&gt; &lt;input type=&quot;text&quot; id=&quot;txt&quot; /&gt; &lt;span id=&quot;sp&quot;&gt;&lt;/span&gt; &lt;script&gt; var txt = document.getElementById('txt'), sp = document.getElementById('sp'), obj = {} // 给对象obj添加msg属性，并设置setter访问器 Object.defineProperty(obj, 'msg', { // 设置 obj.msg 当obj.msg反生改变时set方法将会被调用 set: function (newVal) { // 当obj.msg被赋值时 同时设置给 input/span txt.value = newVal sp.innerText = newVal } }) // 监听文本框的改变 当文本框输入内容时 改变obj.msg txt.addEventListener('keyup', function (event) { obj.msg = event.target.value }) &lt;/script&gt; 动态添加数据的注意点 注意：只有data中的数据才是响应式的，动态添加进来的数据默认为非响应式 可以通过以下方式实现动态添加数据的响应式 1 Vue.set(object, key, value) - 适用于添加单个属性 2 Object.assign() - 适用于添加多个属性 var vm = new Vue({ data: { stu: { name: 'jack', age: 19 } } }) /* Vue.set */ Vue.set(vm.stu, 'gender', 'male') /* Object.assign 将参数中的所有对象属性和值 合并到第一个参数 并返回合并后的对象*/ vm.stu = Object.assign({}, vm.stu, { gender: 'female', height: 180 }) 异步DOM更新 说明：Vue 异步执行 DOM 更新，监视所有数据改变，一次性更新DOM 优势：可以去除重复数据，对于避免不必要的计算和 避免重复 DOM 操作上，非常重要 如果需要那到更新后dom中的数据 则需要通过 Vue.nextTick(callback)：在DOM更新后，执行某个操作（属于DOM操作） 实例调用vm.$nextTick(function () {}) methods: { fn() { this.msg = 'change' this.$nextTick(function () { console.log('$nextTick中打印：', this.$el.children[0].innerText); }) console.log('直接打印：', this.$el.children[0].innerText); } } 指令 解释：指令 (Directives) 是带有 v- 前缀的特殊属性 作用：当表达式的值改变时，将其产生的连带影响，响应式地作用于 DOM v-text 解释：更新DOM对象的 textContent &lt;h1 v-text=&quot;msg&quot;&gt;&lt;/h1&gt; v-html 解释：更新DOM对象的 innerHTML &lt;h1 v-html=&quot;msg&quot;&gt;&lt;/h1&gt; v-bind 作用：当表达式的值改变时，将其产生的连带影响，响应式地作用于 DOM 语法：v-bind:title=&quot;msg&quot; 简写：:title=&quot;msg&quot; &lt;!-- 完整语法 --&gt; &lt;a v-bind:href=&quot;url&quot;&gt;&lt;/a&gt; &lt;!-- 缩写 --&gt; &lt;a :href=&quot;url&quot;&gt;&lt;/a&gt; v-on 作用：绑定事件 语法：v-on:click=&quot;say&quot; or v-on:click=&quot;say('参数', $event)&quot; 简写：@click=&quot;say&quot; 说明：绑定的事件定义在methods &lt;!-- 完整语法 --&gt; &lt;a v-on:click=&quot;doSomething&quot;&gt;&lt;/a&gt; &lt;!-- 缩写 --&gt; &lt;a @click=&quot;doSomething&quot;&gt;&lt;/a&gt; 事件修饰符 .stop 阻止冒泡，调用 event.stopPropagation() .prevent 阻止默认行为，调用 event.preventDefault() .capture 添加事件侦听器时使用事件捕获模式 .self 只当事件在该元素本身（比如不是子元素）触发时，才会触发事件 .once 事件只触发一次 v-model 作用：在表单元素上创建双向数据绑定 说明：监听用户的输入事件以更新数据 案例：计算器 &lt;input type=&quot;text&quot; v-model=&quot;message&quot; placeholder=&quot;edit me&quot;&gt; &lt;p&gt;Message is: {{ message }}&lt;/p&gt; v-for 作用：基于源数据多次渲染元素或模板块 &lt;!-- 1 基础用法 --&gt; &lt;div v-for=&quot;item in items&quot;&gt; {{ item.text }} &lt;/div&gt; &lt;!-- item 为当前项，index 为索引 --&gt; &lt;p v-for=&quot;(item, index) in list&quot;&gt;{{item}} -- {{index}}&lt;/p&gt; &lt;!-- item 为值，key 为键，index 为索引 --&gt; &lt;p v-for=&quot;(item, key, index) in obj&quot;&gt;{{item}} -- {{key}}&lt;/p&gt; &lt;p v-for=&quot;item in 10&quot;&gt;{{item}}&lt;/p&gt; key属性 推荐：使用 v-for 的时候提供 key 属性，以获得性能提升。 说明：使用 key，VUE会基于 key 的变化重新排列元素顺序，并且会移除 key 不存在的元素。 vue key vue key属性的说明 &lt;div v-for=&quot;item in items&quot; :key=&quot;item.id&quot;&gt; &lt;!-- 内容 --&gt; &lt;/div&gt; 样式处理 -class和style 使用方式：v-bind:class=&quot;expression&quot; or :class=&quot;expression&quot; 表达式的类型：字符串、数组、对象（重点） 语法： &lt;!-- 1 --&gt; &lt;div v-bind:class=&quot;{ active: true }&quot;&gt;&lt;/div&gt; ===&gt; 解析后 &lt;div class=&quot;active&quot;&gt;&lt;/div&gt; &lt;!-- 2 --&gt; &lt;div :class=&quot;['active', 'text-danger']&quot;&gt;&lt;/div&gt; ===&gt;解析后 &lt;div class=&quot;active text-danger&quot;&gt;&lt;/div&gt; &lt;!-- 3 --&gt; &lt;div v-bind:class=&quot;[{ active: true }, errorClass]&quot;&gt;&lt;/div&gt; ===&gt;解析后 &lt;div class=&quot;active text-danger&quot;&gt;&lt;/div&gt; --- style --- &lt;!-- 1 --&gt; &lt;div v-bind:style=&quot;{ color: activeColor, 'font-size': fontSize + 'px' }&quot;&gt;&lt;/div&gt; &lt;!-- 2 将多个 样式对象 应用到一个元素上--&gt; &lt;!-- baseStyles 和 overridingStyles 都是data中定义的对象 --&gt; &lt;div v-bind:style=&quot;[baseStyles, overridingStyles]&quot;&gt;&lt;/div&gt; v-if 和 v-show 条件渲染 v-if：根据表达式的值的真假条件，销毁或重建元素 v-show：根据表达式之真假值，切换元素的 display CSS 属性 &lt;p v-show=&quot;isShow&quot;&gt;这个元素展示出来了吗？？？&lt;/p&gt; &lt;p v-if=&quot;isShow&quot;&gt;这个元素，在HTML结构中吗？？？&lt;/p&gt; 提升性能：v-pre 说明：vue会跳过这个元素和它的子元素的编译过程。可以用来显示原始 Mustache 标签。跳过大量没有指令的节点会加快编译。 &lt;span v-pre&gt;{{ this will not be compiled }}&lt;/span&gt; 提升性能：v-once 说明：vue只渲染元素和组件一次。随后的重新渲染，元素/组件及其所有的子节点将被视为静态内容并跳过。这可以用于优化更新性能。 &lt;span v-once&gt;This will never change: {{msg}}&lt;/span&gt; 过滤器 filter(不建议用,可以用计算属性和函数方法替代) 作用：文本数据格式化 过滤器可以用在两个地方：{{}}和 v-bind 表达式 两种过滤器：1 全局过滤器 2 局部过滤器 全局过滤器 说明：通过全局方式创建的过滤器，在任何一个vue实例中都可以使用 注意：使用全局过滤器的时候，需要先创建全局过滤器，再创建Vue实例 显示的内容由过滤器的返回值决定 Vue.filter('filterName', function (value) { // value 表示要过滤的内容 }) 示例： &lt;div&gt;{{ dateStr | date }}&lt;/div&gt; &lt;div&gt;{{ dateStr | date('YYYY-MM-DD hh:mm:ss') }}&lt;/div&gt; &lt;script&gt; Vue.filter('date', function(value, format) { // value 要过滤的字符串内容，比如：dateStr // format 过滤器的参数，比如：'YYYY-MM-DD hh:mm:ss' }) &lt;/script&gt; 局部过滤器 说明：局部过滤器是在某一个vue实例的内容创建的，只在当前实例中起作用 { data: {}, // 通过 filters 属性创建局部过滤器 // 注意：此处为 filters filters: { filterName: function(value, format) {} } } 按键值修饰符 说明：在监听键盘事件时，Vue 允许为 v-on 在监听键盘事件时添加关键修饰符 键盘事件 - 键值修饰符 其他：修饰键（.ctrl等）、鼠标按键修饰符（.left等） // 只有在 keyCode 是 13 时调用 vm.submit() @keyup.13=&quot;submit&quot; // 使用全局按键别名 @keyup.enter=&quot;add&quot; --- // 通过全局 config.keyCodes 对象自定义键值修饰符别名 Vue.config.keyCodes.f2 = 113 // 使用自定义键值修饰符 @keyup.enter.f2=&quot;add&quot; 监视数据变化 - watch 概述：watch是一个对象，键是需要观察的表达式，值是对应回调函数 作用：当表达式的值发生变化后，会调用对应的回调函数完成响应的监视操作 VUE $watch new Vue({ data: { a: 1, b: { age: 10 } }, watch: { a: function(val, oldVal) { // val 表示当前值 // oldVal 表示旧值 console.log('当前值为：' + val, '旧值为：' + oldVal) }, // 监听对象属性的变化 b: { handler: function (val, oldVal) { /* ... */ }, // deep : true表示是否监听对象内部属性值的变化 deep: true }, // 只监视user对象中age属性的变化 'user.age': function (val, oldVal) { }, } }) 计算属性 说明：计算属性是基于它们的依赖进行缓存的，只有在它的依赖发生改变时才会重新求值 注意：Mustache语法 中不要放入太多的逻辑，否则会让模板过重、难以理解和维护 注意：computed中的属性不能与data中的属性同名，否则会报错 Vue computed属性原理 var vm = new Vue({ el: '#app', data: { firstname: 'jack', lastname: 'rose' }, computed: { fullname() { return this.firstname + '.' + this.lastname } } }) 实例生命周期 所有的 Vue 组件都是 Vue 实例，并且接受相同的选项对象即可 (一些根实例特有的选项除外)。 实例生命周期也叫做：组件生命周期 生命周期介绍 vue生命周期钩子函数 简单说：一个组件从开始到最后消亡所经历的各种状态，就是一个组件的生命周期 生命周期钩子函数的定义：从组件被创建，到组件挂载到页面上运行，再到页面关闭组件被卸载，这三个阶段总是伴随着组件各种各样的事件，这些事件，统称为组件的生命周期函数！ 注意：Vue在执行过程中会自动调用生命周期钩子函数，我们只需要提供这些钩子函数即可 注意：钩子函数的名称都是Vue中规定好的！ 钩子函数 - beforeCreate() 说明：在实例初始化之后，数据观测 (data observer) 和 event/watcher 事件配置之前被调用 注意：此时，无法获取 data中的数据、methods中的方法 钩子函数 - created() 注意：这是一个常用的生命周期，可以调用methods中的方法、改变data中的数据 vue实例生命周期 参考1 vue实例生命周期 参考2 使用场景：发送请求获取数据 钩子函数 - beforeMounted() 说明：在挂载开始之前被调用 钩子函数 - mounted() 说明：此时，vue实例已经挂载到页面中，可以获取到el中的DOM元素，进行DOM操作 钩子函数 - beforeUpdated() 说明：数据更新时调用，发生在虚拟 DOM 重新渲染和打补丁之前。你可以在这个钩子中进一步地更改状态，这不会触发附加的重渲染过程。 注意：此处获取的数据是更新后的数据，但是获取页面中的DOM元素是更新之前的 钩子函数 - updated() 说明：组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。 钩子函数 - beforeDestroy() 说明：实例销毁之前调用。在这一步，实例仍然完全可用。 使用场景：实例销毁之前，执行清理任务，比如：清除定时器等 钩子函数 - destroyed() 说明：Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。 自定义指令 作用：进行DOM操作 使用场景：对纯 DOM 元素进行底层操作，比如：文本框获得焦点 vue 自定义指令用法实例 两种指令：1 全局指令 2 局部指令 全局自定义指令 // 第一个参数：指令名称 // 第二个参数：配置对象，指定指令的钩子函数 Vue.directive('directiveName', { // bind中只能对元素自身进行DOM操作，而无法对父级元素操作 // 只调用一次 指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。 bind( el，binding, vnode ) { // 参数详解 // el：指令所绑定的元素，可以用来直接操作 DOM 。 // binding：一个对象，包含以下属性： // name：指令名，不包括 v- 前缀。 // value：指令的绑定值，等号后面的值 。 // oldValue：指令绑定的前一个值，仅在 update 和 componentUpdated 钩子中可用。无论值是否改变都可用。 // expression：字符串形式的指令表达式 等号后面的字符串 形式 // arg：传给指令的参数，可选。例如 v-my-directive:foo 中，参数为 &quot;foo&quot;。 // modifiers：指令修饰符。例如：v-directive.foo.bar中，修饰符对象为 { foo: true, bar: true }。 // vnode：Vue 编译生成的虚拟节点。。 // oldVnode：上一个虚拟节点，仅在 update 和 componentUpdated 钩子中可用。 }, // inserted这个钩子函数调用的时候，当前元素已经插入页面中了，也就是说可以获取到父级节点了 inserted ( el，binding, vnode ) {}, // DOM重新渲染前 update(el，binding, vnode,oldVnode) {}, // DOM重新渲染后 componentUpdated ( el，binding, vnode,oldVnode ) {}, // 只调用一次，指令与元素解绑时调用 unbind ( el ) { // 指令所在的元素在页面中消失，触发 } }) // 简写 如果你想在 bind 和 update 时触发相同行为，而不关心其它的钩子: Vue.directive('自定义指令名', function( el, binding ) {}) // 例： Vue.directive('color', function(el, binding) { el.style.color = binging.value }) // 使用 注意直接些会被i成data中的数据“red” 需要字符串则嵌套引号&quot;'red'&quot; &lt;p v-color=&quot;'red'&quot;&gt;&lt;/p&gt; 局部自定义指令 var vm = new Vue({ el : &quot;#app&quot;, directives: { directiveName: { } } }) vue 剖析Vue原理&amp;实现双向绑定MVVM 组件 组件系统是 Vue 的另一个重要概念，因为它是一种抽象，允许我们使用小型、独立和通常可复用的组件构建大型应用。仔细想想，几乎任意类型的应用界面都可以抽象为一个组件树 创建组件的两种方式：1 全局组件 2 局部组件 全局组件 说明：全局组件在所有的vue实例中都可以使用 注意：先注册组件，再初始化根实例 // 1 注册全局组件 Vue.component('my-component', { // template 只能有一个根元素 template: '&lt;p&gt;A custom component!&lt;/p&gt;', // 组件中的 `data` 必须是函数 并且函数的返回值必须是对象 data() { return { msg: '注意：组件的data必须是一个函数！！！' } } }) // 2 使用：以自定义元素的方式 &lt;div id=&quot;example&quot;&gt; &lt;my-component&gt;&lt;/my-component&gt; &lt;/div&gt; // =====&gt; 渲染结果 &lt;div id=&quot;example&quot;&gt; &lt;p&gt;A custom component!&lt;/p&gt; &lt;/div&gt; // 3 template属性的值可以是： - 1 模板字符串 - 2 模板id template: '#tpl' &lt;script type=&quot;text/x-template&quot; id=&quot;tpl&quot;&gt; &lt;p&gt;A custom component!&lt;/p&gt; &lt;/script&gt; extend：使用基础 Vue 构造器，创建一个“子类”。参数是一个包含组件选项的对象。 // 注册组件，传入一个扩展过的构造器 Vue.component('my-component', Vue.extend({ /* ... */ })) // 注册组件，传入一个选项对象 (自动调用 Vue.extend) Vue.component('my-component', { /* ... */ }) var Home = Vue.extend({ template: '', data() {} }) Vue.component('home', Home) 局部组件 说明：局部组件，是在某一个具体的vue实例中定义的，只能在这个vue实例中使用 var Child = { template: '&lt;div&gt;A custom component!&lt;/div&gt;' } new Vue({ // 注意：此处为 components components: { // &lt;my-component&gt; 将只在当前vue实例中使用 // my-component 为组件名 值为配置对象 'my-component': { template: ``, data () { return { } }, props : [] } } }) is特性 在某些特定的标签中只能存在指定表恰 如ul &gt; li 如果要浏览器正常解析则需要使用is &lt;!-- 案例 --&gt; &lt;ul id=&quot;app&quot;&gt; &lt;!-- 不能识别 --&gt; &lt;my-li&gt;&lt;/my-li&gt; 正常识别 &lt;li is=&quot;my-li&quot;&gt;&lt;/li&gt; &lt;/ul&gt; &lt;script&gt; var vm = new Vue({ el: &quot;#app&quot;, components : { myLi : { template : `&lt;li&gt;内容&lt;/li&gt;` } } }) &lt;/script&gt; 组件通讯 父组件到子组件(props) 方式：通过子组件props属性来传递数据 props是一个数组 注意：属性的值必须在组件中通过props属性显示指定，否则，不会生效 说明：传递过来的props属性的用法与data属性的用法相同 &lt;div id=&quot;app&quot;&gt; &lt;!-- 如果需要往子组件总传递父组件data中的数据 需要加v-bind=&quot;数据名称&quot; --&gt; &lt;hello v-bind:msg=&quot;info&quot;&gt;&lt;/hello&gt; &lt;!-- 如果传递的是字面量 那么直接写--&gt; &lt;hello my-msg=&quot;abc&quot;&gt;&lt;/hello&gt; &lt;/div&gt; &lt;!-- js --&gt; &lt;script&gt; new Vue({ el: &quot;#app&quot;, data : { info : 15 }, components: { hello: { // 创建props及其传递过来的属性 props: ['msg', 'myMsg'], template: '&lt;h1&gt;这是 hello 组件，这是消息：{{msg}} --- {{myMsg}}&lt;/h1&gt;' } } }) &lt;/script&gt; 子组件到父组件(emit) 方式：父组件给子组件传递一个函数，由子组件调用这个函数 说明：借助vue中的自定义事件（v-on:cunstomFn=&quot;fn&quot;） 步骤: 1、在父组件中定义方法 parentFn 2、在子组件 组件引入标签 中绑定自定义事件 v-on:自定义事件名=&quot;父组件中的方法&quot; ==&gt; @pfn=&quot;parentFn&quot; 3、子组件中通过$emit()触发自定义事件事件 this.$emit(pfn,参数列表。。。) &lt;hello @pfn=&quot;parentFn&quot;&gt;&lt;/hello&gt; &lt;script&gt; Vue.component('hello', { template: '&lt;button @click=&quot;fn&quot;&gt;按钮&lt;/button&gt;', methods: { // 子组件：通过$emit调用 fn() { this.$emit('pfn', '这是子组件传递给父组件的数据') } } }) new Vue({ methods: { // 父组件：提供方法 parentFn(data) { console.log('父组件：', data) } } }) &lt;/script&gt; 非父子组件通讯 eventbus(不建议使用,之后会弃用) 在简单的场景下，可以使用一个空的 Vue 实例作为事件总线 $on()：绑定自定义事件(不建议使用,之后会弃用) var bus = new Vue() // 在组件 B 绑定自定义事件 bus.$on('id-selected', function (id) { // ... }) // 触发组件 A 中的事件 bus.$emit('id-selected', 1) 示例：组件A ---&gt; 组件B &lt;!-- 组件A： --&gt; &lt;com-a&gt;&lt;/com-a&gt; &lt;!-- 组件B： --&gt; &lt;com-b&gt;&lt;/com-b&gt; &lt;script&gt; // 中间组件 var bus = new Vue() // 通信组件 var vm = new Vue({ el: '#app', components: { comB: { template: '&lt;p&gt;组件A告诉我：{{msg}}&lt;/p&gt;', data() { return { msg: '' } }, created() { // 给中间组件绑定自定义事件 注意:如果用到this 需要用箭头函数 bus.$on('tellComB', (msg) =&gt; { this.msg = msg }) } }, comA: { template: '&lt;button @click=&quot;emitFn&quot;&gt;告诉B&lt;/button&gt;', methods: { emitFn() { // 触发中间组件中的自定义事件 bus.$emit('tellComB', '土豆土豆我是南瓜') } } } } }) &lt;/script&gt; ref和refs ref：如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例，可以通过实例直接调用组件的方法或访问数据， 我们看一个ref 来访问组件的例子: // 子组件 A.vue export default { data () { return { name: 'Vue.js' } }, methods: { sayHello () { console.log('hello') } } } 复制代码 // 父组件 app.vue &lt;template&gt; &lt;component-a ref=&quot;comA&quot;&gt;&lt;/component-a&gt; &lt;/template&gt; &lt;script&gt; export default { mounted () { const comA = this.$refs.comA; console.log(comA.name); // Vue.js comA.sayHello(); // hello } } &lt;/script&gt; localStorage / sessionStorage 这种通信比较简单,缺点是数据和状态比较混乱,不太容易维护。 通过window.localStorage.getItem(key)获取数据 通过window.localStorage.setItem(key,value)存储数据 注意用JSON.parse() / JSON.stringify() 做数据格式转换 localStorage / sessionStorage可以结合vuex, 实现数据的持久保存,同时使用vuex解决数据和状态混乱问题. 三、provide/ inject 概念: provide/ inject 是vue2.2.0新增的api, 简单来说就是父组件中通过provide来提供变量, 然后再子组件中通过inject来注入变量。 注意: 这里不论子组件嵌套有多深, 只要调用了inject 那么就可以注入provide中的数据，而不局限于只能从当前父组件的props属性中回去数据 举例验证 接下来就用一个例子来验证上面的描述: 假设有三个组件: A.vue、B.vue、C.vue 其中 C是B的子组件，B是A的子组件 // A.vue &lt;template&gt; &lt;div&gt; &lt;comB&gt;&lt;/comB&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import comB from '../components/test/comB.vue' export default { name: &quot;A&quot;, provide: { for: &quot;demo&quot; }, components:{ comB } } &lt;/script&gt; 复制代码 // B.vue &lt;template&gt; &lt;div&gt; {{demo}} &lt;comC&gt;&lt;/comC&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import comC from '../components/test/comC.vue' export default { name: &quot;B&quot;, inject: ['for'], data() { return { demo: this.for } }, components: { comC } } &lt;/script&gt; 复制代码 // C.vue &lt;template&gt; &lt;div&gt; {{demo}} &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { name: &quot;C&quot;, inject: ['for'], data() { return { demo: this.for } } } &lt;/script&gt; vuex状态管理 一般全局的数据处理可以使用,不再赘述 内容分发(插槽) 这个比较复杂,建议直接看文档 插槽使用 案例： &lt;!-- html代码 --&gt; &lt;div id=&quot;app&quot;&gt; &lt;hello&gt; &lt;!-- 如果只有一个slot插槽 那么不需要指定名称 --&gt; &lt;p slot=&quot;插槽名称&quot;&gt;我是额外的内容&lt;/p&gt; &lt;/hello&gt; &lt;/div&gt; // js代码 new vue({ el : &quot;#app&quot;, components : { hello : { template : ` &lt;div&gt; &lt;p&gt;我是子组件中的内容&lt;/p&gt; &lt;slot name=&quot;名称&quot;&gt;&lt;/slot&gt; &lt;/div&gt; ` } } }) 获取组件（或元素） - refs 说明：vm.$refs 一个对象，持有已注册过 ref 的所有子组件（或HTML元素） 使用：在 HTML元素 中，添加ref属性，然后在JS中通过vm.$refs.属性来获取 注意：如果获取的是一个子组件，那么通过ref就能获取到子组件中的data和methods &lt;div id=&quot;app&quot;&gt; &lt;div ref=&quot;dv&quot;&gt;&lt;/div&gt; &lt;my res=&quot;my&quot;&gt;&lt;/my&gt; &lt;/div&gt; &lt;!-- js --&gt; &lt;script&gt; new Vue({ el : &quot;#app&quot;, mounted() { this.$refs.dv //获取到元素 this.$refs.my //获取到组件 }, components : { my : { template: `&lt;a&gt;sss&lt;/a&gt;` } } }) &lt;/script&gt; 路由 详细内容和案例见 [链接](https://www.yuque.com/docs/share/2fcfcf69-9fab-4877-966d-50c5740e9226?# 《vue-router教程》) 路由即：浏览器中的哈希值（# hash）与展示视图内容（template）之间的对应规则 vue中的路由是：hash 和 component的对应关系 在 Web app 中，通过一个页面来展示和管理整个应用的功能。 SPA往往是功能复杂的应用，为了有效管理所有视图内容，前端路由 应运而生！ 简单来说，路由就是一套映射规则（一对一的对应规则），由开发人员制定规则。 当URL中的哈希值（# hash）发生改变后，路由会根据制定好的规则，展示对应的视图内容 基本使用 安装：npm i -S vue-router &lt;div id=&quot;app&quot;&gt; &lt;!-- 5 路由入口 指定跳转到只定入口 --&gt; &lt;router-link to=&quot;/home&quot;&gt;首页&lt;/router-link&gt; &lt;router-link to=&quot;/login&quot;&gt;登录&lt;/router-link&gt; &lt;!-- 7 路由出口：用来展示匹配路由视图内容 --&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;!-- 1 导入 vue.js --&gt; &lt;script src=&quot;./vue.js&quot;&gt;&lt;/script&gt; &lt;!-- 2 导入 路由文件 --&gt; &lt;script src=&quot;./node_modules/vue-router/dist/vue-router.js&quot;&gt;&lt;/script&gt; &lt;script&gt; // 3 创建两个组件 const Home = Vue.component('home', { template: '&lt;h1&gt;这是 Home 组件&lt;/h1&gt;' }) const Login = Vue.component('login', { template: '&lt;h1&gt;这是 Login 组件&lt;/h1&gt;' }) // 4 创建路由对象 const router = new VueRouter({ routes: [ // 路径和组件一一对应 { path: '/home', component: Home }, { path: '/login', component: Login } ] }) var vm = new Vue({ el: '#app', // 6 将路由实例挂载到vue实例 router }) &lt;/script&gt; 重定向 // 将path 重定向到 redirect { path: '/', redirect: '/home' } 路由其他配置 路由导航高亮 说明：当前匹配的导航链接，会自动添加router-link-exact-active router-link-active类 配置：linkActiveClass 匹配路由模式 配置：mode new Router({ routers:[], mode: &quot;hash&quot;, //默认hash | history 可以达到隐藏地址栏hash值 | abstract，如果发现没有浏览器的 API 则强制进入 linkActiveClass : &quot;now&quot; //当前匹配的导航链接将被自动添加now类 }) 路由参数 说明：我们经常需要把某种模式匹配到的所有路由，全都映射到同一个组件，此时，可以通过路由参数来处理 语法：/user/:id 使用：当匹配到一个路由时，参数值会被设置到 this.$route.params 其他：可以通过 $route.query 获取到 URL 中的查询参数 等 // 方式一 &lt;router-link to=&quot;/user/1001&quot;&gt;如果你需要在模版中使用路由参数 可以这样 {{$router.params.id}}&lt;/router-link&gt; // 方式二 &lt;router-link :to=&quot;{path:'/user',query:{name:'jack',age:18}}&quot;&gt;用户 Rose&lt;/router-link&gt; &lt;script&gt; // 路由 var router = new Router({ routers : [ // 方式一 注意 只有/user/1001这种形式能被匹配 /user | /user/ | /user/1001/ 都不能被匹配 // 将来通过$router.params获取参数返回 {id:1001} { path: '/user/:id', component: User }, // 方式二 { path: &quot;user&quot; , component: User} ] }) // User组件： const User = { template: `&lt;div&gt;User {{ $route.params.id }}&lt;/div&gt;` } &lt;/script&gt; &lt;!-- 如果要子啊vue实例中获取路由参数 则使用this.$router.params 获取路由参数对象 --&gt; &lt;!-- {{$router.query}} 获取路由中的查询字符串 返回对象 --&gt; 嵌套路由 - 子路由 路由是可以嵌套的，即：路由中又包含子路由 规则：父组件中包含 router-view，在路由规则中使用 children 配置 // 父组件： const User = Vue.component('user', { template: ` &lt;div class=&quot;user&quot;&gt; &lt;h2&gt;User Center&lt;/h2&gt; &lt;router-link to=&quot;/user/profile&quot;&gt;个人资料&lt;/router-link&gt; &lt;router-link to=&quot;/user/posts&quot;&gt;岗位&lt;/router-link&gt; &lt;!-- 子路由展示在此处 --&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; ` }) // 子组件[简写] const UserProfile = { template: '&lt;h3&gt;个人资料：张三&lt;/h3&gt;' } const UserPosts = { template: '&lt;h3&gt;岗位：FE&lt;/h3&gt;' } // 路由 var router =new Router({ routers : [ { path: '/user', component: User, // 子路由配置： children: [ { // 当 /user/profile 匹配成功， // UserProfile 会被渲染在 User 的 &lt;router-view&gt; 中 path: 'profile', component: UserProfile }, { // 当 /user/posts 匹配成功 // UserPosts 会被渲染在 User 的 &lt;router-view&gt; 中 path: 'posts', component: UserPosts } ] } ] }) vuex状态管理 这个一般非专业前端也用不到,跳过 详细见vuex官网 SPA -单页应用程序 SPA： Single Page Application 单页Web应用（single page application，SPA），就是只有一个Web页面的应用， 是加载单个HTML页面，并在用户与应用程序交互时动态更新该页面的Web应用程序。 单页面应用程序： 只有第一次会加载页面, 以后的每次请求, 仅仅是获取必要的数据.然后, 由页面中js解析获取的数据, 展示在页面中 传统多页面应用程序： 对于传统的多页面应用程序来说, 每次请求服务器返回的都是一个完整的页面 优势 1 减少了请求体积，加快页面响应速度，降低了对服务器的压力 2 更好的用户体验，让用户在web app感受native app的流畅 实现思路和技术点 1 ajax 2 锚点的使用（window.location.hash #） 3 hashchange 事件 window.addEventListener(&quot;hashchange&quot;,function () {}) 4 监听锚点值变化的事件，根据不同的锚点值，请求相应的数据 5 原本用作页面内部进行跳转，定位并展示相应的内容 前端模块化 为什么需要模块化 1 最开始的js就是为了实现客户端验证以及一些简单的效果 2 后来，js得到重视，应用越来越广泛，前端开发的复杂度越来越高 3 旧版本的js中没有提供与模块（module）相关的内容 模块的概念 在js中，一个模块就是实现特定功能的文件（js文件） 遵循模块的机制，想要什么功能就加载什么模块 模块化开发需要遵循规范 模块化解决的问题 1 命名冲突 2 文件依赖（加载文件） 3 模块的复用 4 统一规范和开发方式 JS实现模块化的规范 AMD 浏览器端 requirejs CommonJS nodejs 加载模块：require() 导出模块：module.exports = {} / exports = {} ES6 中的 import / export CMD 浏览器端 玉伯（阿里前端大神） -&gt; seajs UMD 通用模块化规范，可以兼容 AMD、CommonJS、浏览器中没有模块化规范 等这些语法 AMD 的使用 Asynchronous Module Definition：异步模块定义，浏览器端模块开发的规范 代表：require.js 特点：模块被异步加载，模块加载不影响后面语句的运行 1、定义模块 // 语法:define(name, dependencies?, factory); // name表示：当前模块的名称，是一个字符串 可有可无 // dependencies表示：当前模块的依赖项，是一个数组无论依赖一项还是多项 无则不写 // factory表示：当前模块要完成的一些功能，是一个函数 // 定义对象模块 define({}) // 定义方法模块 define(function() { return {} }) // 定义带有依赖项的模块 define(['js/a'], function() {}) 2、加载模块 // - 注意：require的第一个参数必须是数组 // 参数必须是数组 表示模块路径 以当前文件为基准,通过回调函数中的参数获取加载模块中的变量 参数与模块按照顺序一一对应 require(['a', 'js/b'], function(a, b) { // 使用模块a 和 模块b 中的代码 }) 3、路径查找配置 requirejs 默认使用 baseUrl+paths 的路径解析方式 可以使用以下方式避开此设置： 1 以.js结尾 2 以 / 开始 3 包含协议：https:// 或 http:// // 配置示例 // 注意配置应当在使用之前 require.config({ baseUrl: './js' // 配置基础路径为：当前目录下的js目录 }) require(['a']) // 查找 基础路径下的 ./js/a.js // 简化加载模块路径 require.config({ baseUrl: './js', // 配置一次即可，直接通过路径名称（template || jquery）加载模块 paths: { template: 'assets/artTemplate/template-native', jquery: 'assets/jquery/jquery.min' } }) // 加载jquery template模块 require(['jquery', 'template']) 4、非模块化和依赖项支持 1 添加模块的依赖模块，保证加载顺序（deps） 2 将非模块化模块，转化为模块化（exports） // 示例 require.config({ baseUrl: './js', paths: { // 配置路径 noModule: 'assets/demo/noModule' }, // 配置不符合规范的模块项 shim: { // 模块名称 noModule: { deps: [], // 依赖项 exports: 'sayHi' // 导出模块中存在的函数或变量 } } }); // 注意点 如果定义模块的时候，指定了模块名称，需要使用该名称来引用模块 // 定义 这个模块名称与paths中的名称相同 define('moduleA', function() {}) // 导入 require.config({ paths: { // 此处的模块名：moduleA moduleA: 'assets/demo/moduleA' } }) 5、路径加载规则 路径配置的优先级： 1 通过 config 配置规则查找 2 通过 data-main 指定的路径查找 3 以引入 requirejs 的页面所在路径为准查找 &lt;!-- 设置data-main属性 1 data-main属性指定的文件也会同时被加载 2 用于指定查找其他模块的基础路径 --&gt; &lt;script src=&quot;js/require.js&quot; data-main=&quot;js/main&quot;&gt;&lt;/script&gt; axios Promise based HTTP client for the browser and node.js 以Promise为基础的HTTP客户端，适用于：浏览器和node.js 封装ajax，用来发送请求，异步获取数据 安装：yarn add axios axios // 在浏览器中使用，直接引入js文件使用下面的GET/POST请求方式即可 // 1 引入 axios.js // 2 直接调用axios提供的API发送请求 created() { axios.get(url) .then(function(resp) {}) } --- // 配合 webpack 使用方式如下： import Vue from 'vue' import axios from 'axios' // 将 axios 添加到 Vue.prototype 中 Vue.prototype.$axios = axios --- // 在组件中使用： methods: { getData() { this.$axios.get('url') .then(res =&gt; {}) .catch(err =&gt; {}) } } --- // API使用方式： axios.get(url[, config]) axios.post(url[, data[, config]]) axios(url[, config]) axios(config) Get 请求 const url = 'http://vue.studyit.io/api/getnewslist' // url中带有query参数 axios.get('/user?id=89') .then(function (response) { console.log(response); }) .catch(function (error) { console.log(error); }); // url和参数分离，使用对象 axios.get('/user', { params: { id: 12345 } }) Post 请求 不同环境中处理 POST请求 默认情况下，axios 会将JS对象序列化为JSON对象。为了使用 application/x-www-form-urlencoded 格式发送请求，我们可以这样： // 使用 qs 包，处理将对象序列化为字符串 // npm i -S qs // var qs = require('qs') import qs from 'qs' qs.stringify({ 'bar': 123 }) ===&gt; &quot;bar=123&quot; axios.post('/foo', qs.stringify({ 'bar': 123 })) // 或者： axios.post('/foo', 'bar=123&amp;age=19') const url = 'http://vue.studyit.io/api/postcomment/17' axios.post(url, 'content=点个赞不过份') axios.post('/user', qs.stringify({ firstName: 'Fred', lastName: 'Flintstone' })) .then(function (response) { console.log(response); }) .catch(function (error) { console.log(error); }); 全局配置 // 设置请求公共路径： axios.defaults.baseURL = 'http://vue.studyit.io' 拦截器 拦截器会拦截发送的每一个请求，请求发送之前执行request中的函数，请求发送完成之后执行response中的函数 // 请求拦截器 axios.interceptors.request.use(function (config) { // 所有请求之前都要执行的操作 return config; }, function (error) { // 错误处理 return Promise.reject(error); }); // 响应拦截器 axios.interceptors.response.use(function (response) { // 所有请求完成后都要执行的操作 return response; }, function (error) { // 错误处理 return Promise.reject(error); }); ","link":"https://copyer98.github.io/post/vue2教程/"},{"title":"安装 Kali Linux 后需要做的 20 件事","content":"##安装 Kali Linux 后需要做的 20 件事 专门针对Kali用户 Kali Linux是来自Debian的一个特殊版本，Kali Linux同样存在Debian Linux的许多问题。这部分为读者介绍如何解决那些问题。它们并不是Kali Linux特有的问题，你可以不用理它们；不过我看到错误，强迫症就会发作，非解决错误不可。 实用工具和软件 这部分汇集了我觉得有用的一批实用工具和软件。这些是大多数其他Linux发行版里面也有的日常软件，或者至少我认为它们应作为默认安装系统的一部分而出现。 改进和辅助功能 Kali Linux天生具有启动速度快、占用资源少的特点。但如果你有一些CPU和GPU能力可用，不妨试着让Kali Linix的外观更靓丽一些。 专门针对Kali用户 1. 解决有线网络的&quot;设备无法托管&quot;错误 如果你希望NetworkManager（网络管理器）处理在/etc/network/interfaces中启用的接口，只要在/etc/NetworkManager/NetworkManager.conf中设置managed=true。所以，该文件看起来就像： [main] plugins=ifupdown,keyfile [ifupdown] managed=true 请阅读全文：《Debian或Kali Linux中解决有线网络接口的&quot;设备无法托管&quot;错误》。 2. 修复默认的软件库 最简单的办法就是，编辑/etc/apt/sources.list，去掉每一行或在开头用#注释每一行，并添加下面这几行： leafpad /etc/apt/sources.list 用下面几行，注释或去掉现有的配置： ## Regular repositories deb http://http.kali.org/kali kali main non-free contrib deb http://security.kali.org/kali-security kali/updates main contrib non-free ## Source repositories deb-src http://http.kali.org/kali kali main non-free contrib deb-src http://security.kali.org/kali-security kali/updates main contrib non-free 保存并关闭文件。想了解相关细节和介绍，请参阅《添加官方的Kali Linux软件库》一文。 3. 更新、升级和发行版升级 对你安装的Kali进行清洁、更新、升级和发行版升级等处理。 apt-get clean &amp;&amp; apt-get update &amp;&amp; apt-get upgrade -y &amp;&amp; apt-get dist-upgrade -y 4. 解决PulseAudio警告问题 我的Kali经常弹出这个警告信息： [warn] PulseAudio configured for per-user sessions ... (warning). Debian变种版本也会在启动过程中弹出类似的警告信息。为了解决这个问题，键入下面这个命令： leafpad /etc/default/pulseaudio 找到这一行： PULSEAUDIO_SYSTEM_START=0 把0换成1： PULSEAUDIO_SYSTEM_START=1 其中，0表示系统模式下不启动PulseAudio，1表示系统模式下启动PulseAudio。 reboot 想了解相关细节和介绍，请参阅《解决Kali Linux中的PulseAudio configured for per-user sessions ...（warning）》一文。 5. 确保启动时发出声音 遵照下列步骤，即可解决Kali Linux中启动时没有声音的问题。 apt-get install alsa-utils -y 在GNOME桌面（默认是Kali桌面）中： 鼠标右击小小的音量图标，选择Sound Preferences（声音首选项）。 此外，你还可以依次进入到Applications（应用程序）&gt; System Tools（系统工具）&gt; Preferences（首选项）&gt; System Settings（系统设置）&gt; Sound（声音），即可调出同样的选项。 将Output volume（输出音量）滑块切换到ON（打开），类似下面的屏幕截图。这就是你要做的。关闭Sound（声音）窗口。 想了解相关细节和介绍，请参阅《解决Kali Linux中启动时没有声音这个问题》一文。 实用工具和软件 6. 安装Java 进入到下面这个链接，下载jdk7。截至本文截稿时，jdk版本是jdk-7u45-linux-x64。注意：我使用的是x64，即64位版本。32位版本用户应选择相应的版本。这其实不难！ 下面是我使用的方法。截至本文截稿时，可用版本是jdk-7u45-linux-x64.tar.gz。下载该文件，并保存在/root目录中。 tar -xzvf /root/jdk-7u45-linux-x64.tar.gz mv jdk1.7.0_45 /opt cd /opt/jdk1.7.0_45 这一步将已下载的Java版本登记为替代版本，将其改成作为默认版本来使用： update-alternatives --install /usr/bin/java java /opt/jdk1.7.0_45/bin/java 1 update-alternatives --install /usr/bin/javac javac /opt/jdk1.7.0_45/bin/javac 1 update-alternatives --install /usr/lib/mozilla/plugins/libjavaplugin.so mozilla-javaplugin.s /opt/jdk1.7.0_45/jre/lib/amd64/libnpjp2.so 1 update-alternatives --set java /opt/jdk1.7.0_45/bin/java update-alternatives --set javac /opt/jdk1.7.0_45/bin/javac update-alternatives --set mozilla-javaplugin.so /opt/jdk1.7.0_45/jre/lib/amd64/libnpjp2.so 参阅《在Kali Linux中安装Java JDK》一文，即可详细了解逐步操作和测试选项。 7. 安装Flash 这件事情相当简单、容易，对大多数人来说应该没有问题：在终端中，键入这个命令： apt-get install flashplugin-nonfree 然后键入： update-flashplugin-nonfree - -install 就是这样。你的flash现在应该能够正常工作了。 参阅《在Kali Linux中安装Flash》一文，以便了解逐步操作和测试选项。如果有些人使用上述方法安装失败，该文还给出了Flash手动安装步骤。 8. 安装File Roller（归档管理器） Kali Linux缺少一个真正的GUI归档管理器。使用下面这个命令来安装归档管理器（File Roller）： apt-get install unrar unace rar unrar p7zip zip unzip p7zip-full p7zip-rar file-roller -y 现在你可以在Applications（应用程序）&gt; Accessories（附件）&gt; Archive Manager（归档管理器）中找到归档管理器。 9. 添加标准用户 默认情况下，Kali Linux只有root用户。虽然大多数应用程序需要root访问权，但添加第二个用户总归是个好主意。打开终端，键入下面这个命令，即可创建新用户（把user1换成你想要的用户名称）。 useradd -m user1 （注意：-m意味着创建通常是/home/username的主目录） 现在为该用户设置密码： passwd user1 将所需密码输入两次。添加用户到sudo群组（允许用户进行安装软件、允许打印、使用特权模式等操作）。 usermod -a -G sudo user1 （注意：-a意味着附加或添加，-G意味着指定一个群组/多个群组）。将之前创建的用户的默认外壳改成bash： chsh -s /bin/bash user1 想了解更多内容，请参阅这篇详细而深入的文章：《如何在Kali Linux中添加/删除用户（标准用户/非root用户）》，参阅http://www.blackmoreops.com/2013/11/27/how-to-add-remove-user-standard-user-non-root-in-kali-linux/。该文解释了了如何添加用户，而所有的用户目录也已经到位（因而避免了&quot;无法更新.ICEauthority var/lib/gdm3/.ICEauthority&quot;或含有.ICEauthority或一般权限的任何错误。） 10. 添加add-apt-repository Debian让用户可以通过一个名为add-apt-repository的应用程序，添加和使用PPA软件库，不过Kali Linux在其默认的程序包列表中并不含有该应用程序。就Kali而言，由于这是个特殊用途的应用程序，已进行了某些改动，以便让它适用于最擅长的地方（渗透测试）。想通过add-apt-repository应用程序启用PPA软件库，遵照下面几个步骤。 首先安装Python软件属性程序包。 apt-get install python-software-properties 接下来安装apt-file。 apt-get install apt-file 更新apt-file。 apt-file update 这需要一点时间，所以万一你的apt-file更新起来很慢，可能想试试一并解决这个问题。（注意：我的/etc/apt/sources.list文件中有repo.kali.org，而不是http.kali.org。）一旦apt-file更新完毕，你应该能够搜索它了。 apt-file search add-apt-repository 你的输出结果应该看起来类似这样： python-software-properties: /usr/bin/add-apt-repository python-software-properties: /usr/share/man/man1/add-apt-repository.1.gz 位于/usr/bin/add-apt-repository的默认add-apt-repository应用程序适用于Debian。所以，如果你使用Kali，它很可能无法工作。我在本文末尾处添加了一个巧妙的解决办法，如果你喜欢的话，可以在VirtualBox上一下。但我发现，我们完全可以模仿Ubuntu Oneiric，让add-apt-repository正常工作。 cd /usr/sbin vi add-apt-repository 添加下列代码，并保存文件。 #!/bin/bash if [ $# -eq 1 ] NM=`uname -a &amp;&amp; date` NAME=`echo $NM | md5sum | cut -f1 -d&quot; &quot;` then ppa_name=`echo &quot;$1&quot; | cut -d&quot;:&quot; -f2 -s` if [ -z &quot;$ppa_name&quot; ] then echo &quot;PPA name not found&quot; echo &quot;Utility to add PPA repositories in your debian machine&quot; echo &quot;$0 ppa:user/ppa-name&quot; else echo &quot;$ppa_name&quot; echo &quot;deb http://ppa.launchpad.net/$ppa_name/ubuntu oneiric main&quot; &gt;&gt; /etc/apt/sources.list apt-get update &gt;&gt; /dev/null 2&gt; /tmp/${NAME}_apt_add_key.txt key=`cat /tmp/${NAME}_apt_add_key.txt | cut -d&quot;:&quot; -f6 | cut -d&quot; &quot; -f3` apt-key adv --keyserver keyserver.ubuntu.com --recv-keys $key rm -rf /tmp/${NAME}_apt_add_key.txt fi else echo &quot;Utility to add PPA repositories in your debian machine&quot; echo &quot;$0 ppa:user/ppa-name&quot; fi 注意：在echo &quot;deb http://ppa.launchpad.net/$ppa_name/ubuntu oneiric main&quot; &gt;&gt; /etc/apt/sources.list这一行中，我使用了Oneiric。你可以根据自己的选择，试着使用Lucid、Raring或Saucy。现在，使用chmod和chown这两个命令，对文件进行相应的操作。 chmod +x /usr/sbin/add-apt-repository chown root:root /usr/sbin/add-apt-repository 由于我们已添加了正确的代码，我们就可以使用add-apt-repository，添加PPA软件库。我试着输入下面这两个命令，在Kali Linux中添加主题和自定义图标。 /usr/sbin/add-apt-repository ppa:noobslab/themes /usr/sbin/add-apt-repository ppa:alecive/antigone 我删除了本文中的所有屏幕截图，但如果你想看个清楚，了解具体是如何工作的，建议你参阅《在Kali Linux中添加PPA软件库add-apt-repository》一文，了解更多细节。 11. 安装Tor Tor是自由软件，也是一种开放网络，可以帮助你防御流量分析。流量分析是一种网络监视行为，会危及个人自由和隐私、机密性的商业活动和关系以及国家安全。该指南为你详细介绍了在Kali Linux中安装Tor的步骤。Tor保护你的方法是，通过由全球广大志愿者运营的一个分布式中转网络，传递你的通信内容：它可以防止有人监视你的互联网连接、进而了解你访问哪些网站，它还可以防止你访问的网站了解你的实际位址。 Tor在Kali软件库中就用；想直接从软件库安装它，只要打开终端，键入这个命令： apt-get install tor 从命令行启用Tor服务： service tor start 使用proxychains命令和Tor，实现安全浏览： proxychains iceweasel 为了在本文中确保行文简单，我只显示了使用Tor的一方面。你可以在《在Kali Linux中安装Tor》一文中详细阅读完整细节，详见http://www.blackmoreops.com/2013/12/16/installing-tor-kali-linux/。 12. 安装Filezilla FTP客户端 要是缺少功能完备的FTP客户端，任何Linux安装都谈不上是完整的。Filezilla是最好的FTP客户端，所以使用下面这个命令，安装Filezilla： apt-get install filezilla filezilla-common -y 13. 安装HTOP和NetHogs HTOP是个特别的工具，显示了运行中的进程和所使用的内存，包括更多的详细信息。（你也可以使用top命令，但HTOP完全有用得多。）NetHogs也很有用，它按接口显示了应用程序所用的流量。使用下面这个命令，安装这两个工具： apt-get install htop nethogs -y 你现在可以使用下面几个命令来运行它们了： htop nethogs eth0 nethogs wlan0 你会喜欢使用这些小巧工具的，这点我几乎可以肯定。 14. 为显卡安装专有的驱动程序 你可能需要安装专有的驱动程序，以发掘更多的功能特性，这取决于你使用哪种显卡（ADM还是英伟达）。我写过一篇详细的文章，介绍了如何在Kali Linux中安装AMD ATI专有驱动程序（fglrx）。 英伟达用户完全可以遵照安装英伟达驱动程序的官方说明文档。要是官方说明文档不管用，或者你已无计可施，不妨关注我写过的这另一篇文章：《如何手动安装英伟达二进制驱动程序》。 15. 安装Recordmydesktop和Reminna远程桌面客户端 Recordmydesktop让你能够录制在Kali Linux中的活动，并制作视频。Remmina类似Windows远程桌面客户端。两者都非常实用。可以使用下面这个命令安装它们： apt-get install gtk-recordmydesktop recordmydesktop remmina -y 16. 安装GDebi程序包管理器 dpkg是一个功能强大的工具，但它并不自动安装依赖项。为此，我们需要某种程序包安装工具，以便在安装.deb程序包的同时，可以去获取所有必要的依赖项。眼下最出色的程序包安装工具非gdebi莫属。使用下面这个命令来安装它： apt-get install gdebi -y 改进和辅助功能 17. 安装主题 安装主题、美化桌面是个好主意。Kali的默认桌面单调而乏味。你可以使用两种不同的方法来更改主题。 手动安装主题 通过PPA软件库安装主题 请阅读此处的细节，即可了解如何在Kali Linux中更改或安装GTK3主题。 18. 安装一种新的桌面环境（我青睐XFCE） 我青睐XFCE桌面，但你可以试着在Kali Linux中安装/删除不同的桌面环境或窗口管理器。根据你的需要，选择下列链接： 1.《如何在Kali Linux中安装/删除XFCE桌面环境？》，参阅http://www.blackmoreops.com/2013/10/29/how-to-install-remove-xfce-desktop-environment-in-kali-linux/。 \\2. 《如何在Kali Linux中安装/删除不同的KDE桌面环境？》，参阅http://www.blackmoreops.com/2013/10/29/how-to-install-remove-different-kde-desktop-environments-in-kali-linux/。 \\3. 《如何在Kali Linux中安装/删除LXDE桌面环境？》，参阅http://www.blackmoreops.com/2013/10/29/how-to-install-remove-lxde-desktop-environment-in-kali-linux/。 \\4. 《如何在Kali Linux中安装/删除GNOME桌面环境？》，参阅http://www.blackmoreops.com/2013/10/29/how-to-install-remove-gnome-desktop-environment-on-kali-linux/。 \\5. 《如何在Kali Linux中安装/删除Cinnamon桌面环境？》，参阅http://www.blackmoreops.com/2013/10/29/how-to-install-remove-cinnamon-desktop-environment-in-kali-linux/。 \\6. 《如何在Kali Linux中安装/删除MATE桌面环境？》，参阅http://www.blackmoreops.com/2013/10/29/how-to-install-remove-mate-desktop-environment-in-kali-linux/。 最后，遵照这些操作步骤，永久性地更换桌面环境（也就是启动进入到XFCE，而不是GNOME）。 19. 启用自动登录用户 这是个简单的变更。只要打开并编辑名为/etc/gdm3/daemon.conf的文件，假设你在使用GNOME显示管理器（gmd3）作为主要的显示管理器。你可能想要另外也能试一下其他桌面。下面这个链接介绍了《如何在Kali Linux中添加/删除不同的桌面管理器》，详见http://www.blackmoreops.com/2013/10/11/how-to-installremove-different-desktop-environment-or-window-manager-in-kali-linux-1-x/。 root@kali:~# leafpad /etc/gdm3/daemon.conf 在daemon即守护程序部分，将用于自动登录的那两行代码取消注释。它最后应该看起来像这样： [daemon] # Enabling automatic login AutomaticLoginEnable = true AutomaticLogin = root 就是这样，容易得很。要是你想知道如何使用不同于root用户的用户，方法如下： [daemon] # Enabling automatic login AutomaticLoginEnable = true AutomaticLogin = myanotheruser 最后但并非最不重要的是，重启系统，核实一下是否管用。（这会管用，因为它是Linux，Kali很出色。） reboot 你可能想要采取进一步行动，或者如果你是KDE用户，那么这里的操作步骤介绍了如何在Kali Linux中，系统启动时，让root用户自动登录（GNOME和KDE），详见http://www.blackmoreops.com/2013/12/19/auto-login-root-user-system-start-kali-linux-gnome-kde/。该文还介绍了如何让不同的非root用户实现自动登录，相当方便。 下面这部分解释了如何更充分地发挥你系统的功能，尤其是发挥显卡的功能。 20. 发掘GPU处理的能力 最后但并非最不重要的是，在你试图破解密码时，GPU处理速度要快得多。你可以选择下面介绍的几种方法，具体取决于所使用的显卡： a. AMD显卡 《在Kali Linux 1.x中安装AMD ATI驱动程序（fglrx）》，参阅：http://www.blackmoreops.com/2013/10/22/install-amd-ati-driver-fglrx-in-kali-linux-1-x/。 然后参阅其余指南文章： 《如何在Kali Linux中安装AMD APP SDK？》 《如何在Kali Linux中安装Pyrit？》 《如何在Kali Linux中安装CAL++？》 b. 英伟达显卡 英伟达显卡用户完全可以参阅安装英伟达驱动程序的官方说明文档。如果官方说明文档不管用或者你已无计可施，不妨参阅我写过的另一篇文章，介绍如何手动安装英伟达显卡二进制驱动程序。 《如何在Kali Linux中安装英伟达内核模块Cuda和Pyrit？》，参阅http://www.blackmoreops.com/2013/10/20/how-to-install-nvidia-kernel-module-cuda-and-pyrit/。 ","link":"https://copyer98.github.io/post/安装 Kali Linux 后需要做的 20 件事/"},{"title":"Hello Gridea","content":"👏 欢迎使用 Gridea ！ ✍️ Gridea 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ... Github Gridea 主页 示例网站 特性👇 📝 你可以使用最酷的 Markdown 语法，进行快速创作 🌉 你可以给文章配上精美的封面图和在文章任意位置插入图片 🏷️ 你可以对文章进行标签分组 📋 你可以自定义菜单，甚至可以创建外部链接菜单 💻 你可以在 Windows，MacOS 或 Linux 设备上使用此客户端 🌎 你可以使用 𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌 或 Coding Pages 向世界展示，未来将支持更多平台 💬 你可以进行简单的配置，接入 Gitalk 或 DisqusJS 评论系统 🇬🇧 你可以使用中文简体或英语 🌁 你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力 🖥 你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步 🌱 当然 Gridea 还很年轻，有很多不足，但请相信，它会不停向前 🏃 未来，它一定会成为你离不开的伙伴 尽情发挥你的才华吧！ 😘 Enjoy~ ","link":"https://copyer98.github.io/post/hello-gridea/"},{"title":"jQuery ajax方法","content":"jquery中的ajax方法参数总是记不住，这里记录一下。 1.url: 要求为String类型的参数，（默认为当前页地址）发送请求的地址。 2.type: 要求为String类型的参数，请求方式（post或get）默认为get。注意其他http请求方法，例如put和delete也可以使用，但仅部分浏览器支持。 3.timeout: 要求为Number类型的参数，设置请求超时时间（毫秒）。此设置将覆盖$.ajaxSetup()方法的全局设置。 4.async: 要求为Boolean类型的参数，默认设置为true，所有请求均为异步请求。如果需要发送同步请求，请将此选项设置为false。注意，同步请求将锁住浏览器，用户其他操作必须等待请求完成才可以执行。 5.cache: 要求为Boolean类型的参数，默认为true（当dataType为script时，默认为false），设置为false将不会从浏览器缓存中加载请求信息。 6.data: 要求为Object或String类型的参数，发送到服务器的数据。如果已经不是字符串，将自动转换为字符串格式。get请求中将附加在url后。防止这种自动转换，可以查看 processData选项。对象必须为key/value格式，例如{foo1:&quot;bar1&quot;,foo2:&quot;bar2&quot;}转换为&amp;foo1=bar1&amp;foo2=bar2。如果是数组，JQuery将自动为不同值对应同一个名称。例如{foo:[&quot;bar1&quot;,&quot;bar2&quot;]}转换为&amp;foo=bar1&amp;foo=bar2。 7.dataType: 要求为String类型的参数，预期服务器返回的数据类型。如果不指定，JQuery将自动根据http包mime信息返回responseXML或responseText，并作为回调函数参数传递。可用的类型如下： xml：返回XML文档，可用JQuery处理。 html：返回纯文本HTML信息；包含的script标签会在插入DOM时执行。 script：返回纯文本JavaScript代码。不会自动缓存结果。除非设置了cache参数。注意在远程请求时（不在同一个域下），所有post请求都将转为get请求。 json：返回JSON数据。 jsonp：JSONP格式。使用SONP形式调用函数时，例如myurl?callback=?，JQuery将自动替换后一个“?”为正确的函数名，以执行回调函数。 text：返回纯文本字符串。 8.beforeSend： 要求为Function类型的参数，发送请求前可以修改XMLHttpRequest对象的函数，例如添加自定义HTTP头。在beforeSend中如果返回false可以取消本次ajax请求。XMLHttpRequest对象是惟一的参数。 function(XMLHttpRequest) { this; //调用本次ajax请求时传递的options参数 } 9.complete： 要求为Function类型的参数，请求完成后调用的回调函数（请求成功或失败时均调用）。参数：XMLHttpRequest对象和一个描述成功请求类型的字符串。 function(XMLHttpRequest, textStatus) { this; //调用本次ajax请求时传递的options参数 } 10.success：要求为Function类型的参数，请求成功后调用的回调函数，有两个参数。 ​ (1)由服务器返回，并根据dataType参数进行处理后的数据。 ​ (2)描述状态的字符串。 function(data, textStatus){ //data可能是xmlDoc、jsonObj、html、text等等 this; //调用本次ajax请求时传递的options参数 } 11.error: 要求为Function类型的参数，请求失败时被调用的函数。该函数有3个参数，即XMLHttpRequest对象、错误信息、捕获的错误对象(可选)。ajax事件函数如下： function(XMLHttpRequest, textStatus, errorThrown){ //通常情况下textStatus和errorThrown只有其中一个包含信息 this; //调用本次ajax请求时传递的options参数 } 12.contentType： 要求为String类型的参数，当发送信息至服务器时，内容编码类型默认为&quot;application/x-www-form-urlencoded&quot;。该默认值适合大多数应用场合。 13.dataFilter： 要求为Function类型的参数，给Ajax返回的原始数据进行预处理的函数。提供data和type两个参数。data是Ajax返回的原始数据，type是调用jQuery.ajax时提供的dataType参数。函数返回的值将由jQuery进一步处理。 ​ function(data, type){ //返回处理后的数据 return data; } 14.dataFilter： 要求为Function类型的参数，给Ajax返回的原始数据进行预处理的函数。提供data和type两个参数。data是Ajax返回的原始数据，type是调用jQuery.ajax时提供的dataType参数。函数返回的值将由jQuery进一步处理。 function(data, type) { //返回处理后的数据 return data; } 15.global： 要求为Boolean类型的参数，默认为true。表示是否触发全局ajax事件。设置为false将不会触发全局ajax事件，ajaxStart或ajaxStop可用于控制各种ajax事件。 16.ifModified： 要求为Boolean类型的参数，默认为false。仅在服务器数据改变时获取新数据。服务器数据改变判断的依据是Last-Modified头信息。默认值是false，即忽略头信息。 17.jsonp： 要求为String类型的参数，在一个jsonp请求中重写回调函数的名字。该值用来替代在&quot;callback=?&quot;这种GET或POST请求中URL参数里的&quot;callback&quot;部分，例如{jsonp:'onJsonPLoad'}会导致将&quot;onJsonPLoad=?&quot;传给服务器。 18.username： 要求为String类型的参数，用于响应HTTP访问认证请求的用户名。 19.password： 要求为String类型的参数，用于响应HTTP访问认证请求的密码。 20.processData： 要求为Boolean类型的参数，默认为true。默认情况下，发送的数据将被转换为对象（从技术角度来讲并非字符串）以配合默认内容类型&quot;application/x-www-form-urlencoded&quot;。如果要发送DOM树信息或者其他不希望转换的信息，请设置为false。 21.scriptCharset： 要求为String类型的参数，只有当请求时dataType为&quot;jsonp&quot;或者&quot;script&quot;，并且type是GET时才会用于强制修改字符集(charset)。通常在本地和远程的内容编码不同时使用。 案例代码： $(function(){ $('#send').click(function(){ $.ajax({ type: &quot;GET&quot;, url: &quot;test.json&quot;, data: {username:$(&quot;#username&quot;).val(), content:$(&quot;#content&quot;).val()}, dataType: &quot;json&quot;, success: function(data){ $('#resText').empty(); //清空resText里面的所有内容 var html = ''; $.each(data, function(commentIndex, comment){ html += '&lt;div class=&quot;comment&quot;&gt;&lt;h6&gt;' + comment['username'] \\+ ':&lt;/h6&gt;&lt;p class=&quot;para&quot;' + comment['content'] \\+ '&lt;/p&gt;&lt;/div&gt;'; }); $('#resText').html(html); } }); }); }); $.ajax验证登录： &lt;script type=&quot;text/javascript&quot; language=&quot;javascript&quot;&gt; function IbtnEnter_onclick() { checklogin(); return false; } function checklogin() { if ($(&quot;#TxtUserName&quot;).val() == &quot;&quot;) { alert(&quot;用户名不能为空！&quot;); $(&quot;#TxtUserName&quot;).focus(); return false; } if ($(&quot;#TxtPassword&quot;).val() == &quot;&quot;) { alert(&quot;密码不能为空！&quot;); $(&quot;#TxtPassword&quot;).focus(); return false; } $.ajax({ type: &quot;POST&quot;, url: &quot;ajax/Handler.ashx?M=&quot; + Math.random(), data: &quot;username=&quot; + $(&quot;#TxtUserName&quot;).val().toString() + &quot;&amp;pwd=&quot; + $(&quot;#TxtPassword&quot;).val().toString(), success: function (data) { if (data == &quot;1&quot;) { location.href = &quot;index.aspx&quot;; return true; } else { alert(&quot;请确认您输入的用户名或密码输入是否正确！&quot;); $(&quot;#TxtUserName&quot;).val(&quot;&quot;); $(&quot;#TxtPassword&quot;).val(&quot;&quot;); $(&quot;#TxtUserName&quot;).focus(); return false; } } }) } &lt;/script&gt; 一般处理程序 &lt;%@ WebHandler Language=&quot;C#&quot; Class=&quot;Handler&quot; %&gt; using System; using System.Web; using System.Data.SqlClient; using System.Web.SessionState;//继承接口IReadOnlySessionState需要引入的命名空间 public class Handler : IHttpHandler, IRequiresSessionState { SqlHelper helper = new SqlHelper(); public void ProcessRequest(HttpContext context) { context.Response.ContentType = &quot;text/plain&quot;; string username = context.Request.Params[&quot;username&quot;].ToString().Trim(); string pwd = context.Request.Params[&quot;pwd&quot;].ToString().Trim(); if (username != &quot;&quot; &amp;&amp; pwd != &quot;&quot;) { string sql = @&quot;SELECT * FROM [USER] WHERE USERNAME='&quot;+username+&quot;' AND PASSWORD='&quot;+pwd+&quot;' &quot;; if (!helper.Exists(sql)) { context.Response.Write(&quot;0&quot;); } else { SqlDataReader reader = helper.ExecuteReader(sql); while (reader.Read()) { context.Response.Write(&quot;1&quot;); context.Session[&quot;username&quot;] = username.ToString().Trim(); context.Session[&quot;pwd&quot;] = pwd.ToString().Trim(); } } } } public bool IsReusable { get { return false; } } } ","link":"https://copyer98.github.io/post/jquery中的ajax方法参数总是记不住，这里记录一下/"},{"title":"js开发工具大全","content":"标签: js,前端 js 开发工具 JavaScript 开发工具大全 为了保证可读性，本文采用意译而非直译。另外，本文版权归原作者所有，翻译仅用于学习。 简介 2017 年 1 月，Stack Overflow 年度开发者调研一共访问了64000个程序员，发现 JavaScript 已经连续 5 年成为最流行的编程语言。 这篇博客将介绍一些常用的 JavaScript 开发工具： 构建&amp;自动化 IDE&amp;编辑器 文档 测试 调试 安全 代码优化&amp;分析 包管理 构建 &amp; 自动化 Webpack对 JavaScript 应用依赖的所有模块进行静态分析，生成依赖图，然后将它们打包成数个静态文件。 Grunt以将重复耗时的任务自动化。Grunt 的生态系统非常大，有超过 6010 个插件。 Gulp发布于 Grunt 之后，采用了完全不同的方式，使用 JavaScript 函数定义任务。它有超过 2770 个插件，并且提供了更好的控制。 Browserify使得开发者可以在浏览器使用CommonJS 模块。开发者像在 node 环境一样，通过require('modules')来组织模块之间的引用和依赖，Browserify 将这些依赖打包成浏览器可以直接引用的 JS 文件。 Brunch非常简单，速度很快。Brunch 的配置文件非常简单，入门文档非常详细。Brunch 会自动生成 Source Map，方便了开发者 Debug。 Yeoman可以用于任何编程语言(JavaScript, Python, C#, Java, etc.)。它是前端开发的脚手架，有 6213 个插件。 IDE &amp; 编辑器 WebStorm是一款强大的 JavaScript IDE。它支持多种框架和 CSS 语言，包括前端，后端，移动端以及桌面应用。WebStorm 可以无缝整合第三方工具，例如构建构建、语法检查构建 linter 等等。它提供了代码补全，实时错误监测，导航，内置控制台，各种插件等一系统功能。 Atom是 GitHub 团队开发的。开发者可以很容易地对 Atom 进行自定义。Atom 自带了一个包管理工具，代码补全，文件系统浏览器，支持多个平台以及其他有用的功能。 Visual Studio Code是微软开发的 IDE，支持 TypeScript。它提供了代码补全，语法高亮，支持 Git 命令等等。另外，它还有非常多的插件。 Brackets是一个轻量级的开源编辑器。它专注于可视化工具，可以帮助开发者开发 Web 应用。Brackets 支持实时预览以及行内编辑。 文档 Swagger提供了一系列规则用于描述 API。使用 Swagger，可以创建清晰的文档，并且自动化 API 相关的操作(例如功能测试)。 JSDoc可以根据 javascript 文件中注释信息，生成 JavaScript 应用程序或库、模块的 API 文档。JSDoc 可以用于管理大型项目。 **jGrouseDoc **是一个开源工具，可根据 JavaScript 注释生成类似 Jaavdoc 的源码文档。它不仅可以为变量和函数生成文档，还可以为模块等其他元素生成文档。 YUIDoc基于 Nodejs，可以将文档中的注释生成 API 文档。它使用类似于 Javadoc 与 Doxygen 的语法，并且支持实时预览，支持各种语言，并且支持标记语言。 **Docco **是免费的文档工具，由 Literate CoffeeScript 编写。它将代码中的注释生成 HTML 文档。Docco 并不限于 JavaScript，同时支持 Python, Ruby, Clojure 等语言。 测试 Jasmine是一个行为驱动开发(BDD)框架，用于测试 JavaScript 代码。它不依赖任何第三方模块，也不需要 DOM。它的语法非常简单易懂，使得编写测试变得很简单。另外，它也可以用于测试 Node.js，Python 以及 Ruby。 Mocha是一个功能测试框架，用于测试 Node.js 以及浏览器端 JavaScript。作为开发者首选的测试框架，它可以自由的编写测试组，提供详细的测试报告，同时让异步测试非常简单。Mocha 通常与断言库Chai来验证测试结果。 PhantomJS用于前端单元测试。由于 PhantomJS 是一个无界面的 Webkit 浏览器引擎，与直接使用浏览器测试相比，使用 PhantomJS 脚本可以运行得更快。它支持各种网页标准，例如 JSON, Canvas, DOM 操作, SVG 以及 CSS 选择器。 Protractor是一个端到端测试框架，用于测试 Angular 应用。它是基于 WebDriverJS 构建的，它可以通过浏览器事件或者原生事件，从而模拟真实用户，来测试应用。 调试 JavaScript Debugger由 Mozilla Developer Network (MDN)开发，可以独立用于调试 Node.js 代码，或者用于其他浏览器。Firefox 提供了本地和远程调试功能，并且，Firefox 安卓端也用于调试运行在安卓应用。 Chrome Dev Tools提供了一系列工具，可以用于调试 JavaScript 代码，编辑 CSS，以及测试应用性能。 ng-inspector是 Firefox，Chrome 和 Safari 浏览器插件，可以帮助开发者开发、理解以及调试 AngularJS 应用。它提供了实时更新，DOM 高亮等功能。 Augury是一个 Chrome 插件，可以用于调试 Angular 2 应用。它让开发者可以直接查看应用结构，操作特征以及状态变化。 安全 Snyk是一个付费服务，用于发现、修复和预防 JavaScript，Node.js 和 Ruby 应用的已知漏洞。Snyk 拥有自己的漏洞库，以及 NSP 和 NIST NVD 的漏洞数据。它允许开发者使用它们的补丁和更新来修复这些安全漏洞。 Node Security Project提供了工具用于扫描依赖来监测漏洞。NSP 使用自己的漏洞数据，以及来自 NIST NVD 的漏洞数据。NSP 支持集成 GitHub 和 CI 软件，实时监测和报警，并且可以提供如何修复 Node.js 应用漏洞的建议。 RetireJS是一个开源的依赖监测工具。它包含了多个组件，包括命令行工具，Grunt 插件，Firefox 和 Chrome 插件，Burp 和 OWASP ZAP 插件。Retirejs 从 NIST NVD，漏洞追踪系统，博客和邮件列表等手机漏洞数据。 Gemnasium是一个付费工具，不过有免费方案。它支持各种技术，比如 Ruby, PHP, Bower, Python 和 npm。Gemnasium 提供很多非常有用的特性，比如自动更新，实时报警以及 Slack 集成等。 OSSIndex支持多个生态系统(Java, JavaScript 和.NET/C#)，以及多个平台，例如 NuGet, npm, Bower, Chocolatey, Maven, Composer, Drupal 和 MSI。它从 NVD 以及其他来源收集漏洞数据。 代码优化 &amp; 分析 JSLint是一个 Web 服务，用于验证 JavaScript 的代码质量。当它诊断到一个问题时，它会返回问题的大致位置和出错信息。JSLint 可以分析一些编码规范以及语法错误。 JSHint可以发现 JavaScript 中的错误以及一些潜在的问题。JSHint 是一个静态代码分析工具，旨在帮助开发者编写大型的程序。它可以诊断语法错误、隐形类型转换等问题，但是它并不能确定你的应用是否正确、性能是否足够好、以及是否会发生内存泄漏。 JSHint 是 JSLint 的一个 fork。 ESLint是一个开源诊断工具，用于 JSX 和 JavaScript 应用。它可以帮助开发者发现可疑的或者不符合特定编程规范的代码。它帮助开发者在没有执行代码之前发现 JS 代码中问题，节省了不少时间。ESLint 由 Node.js 编写，可以使用 NPM 安装。 Flow是 JavaScript 代码静态类型检测器，由 Facebook 开发。Flow 可以在编码时检查到类型错误并做出提示。 包管理 Bower是一个用于管理前端依赖的包管理器，Twitter 创建。它提供了大量可供使用的依赖包，帮助 JavaScript 开发者更方便地管理前端依赖的 JS 库。 NPM是node package manager的缩写，事实上 NPM 包可以用于前后端。它是 JavaScript 包管理系统，也是世界上最大的依赖库，有超过 475,000 个模块。 Yarn是 Facebook, Google, Exponent 和 Tilde 开发的一款新的 JavaScript 包管理工具。与 NPM 相比，它解决了安全、性能以及一致性问题。 Duo吸取了 Component, Browserify 和 Go 的经验，致力于简化大型 Web 应用的构建过程。 原文: THE ULTIMATE LIST OF JAVASCRIPT TOOLS 译者: Fundebug ","link":"https://copyer98.github.io/post/js开发工具大全/"},{"title":"linux基本知识","content":"标签： linux Linux 的命令行 第一章 安装桌面环境: login 进入系统之后，开始进行用户界面的安装。首先输入如下命令： sudo apt-get install xinit 上述安装完毕之后，再安装环境管理器。本人亲测安装的是 GNOME。使用如下命令安装： sudo apt-get install gdm 然后，安装桌面环境。 本人亲测安装的是 KUbuntu。安装命令如下： sudo apt-get install kubuntu-desktop sudo apt-get install gnome-session-fallback 或者： sudo apt-get install gnome-panel 。安装时的界面如下所示 安装中文语言包 sudo apt-get install language-pack-zh-han* 安装 gnome 包 sudo apt-get install language-pack-gnome-zh-han* 安装 kde 包 sudo apt-get install language-pack-kde-zh-han* 到这里就能够查看目录下面的中文字符了。 最后运行语言支持检查 sudo apt install $(check-language-support) 会更新最新的语言支持包设置语言:改英文: 用 vi(或 nano 等文本编辑器)打开 /etc/default/locale 文件将原来的配置内容修改为 LANG=”en_US.UTF-8″ LANGUAGE=”en_US:en” 再在终端下运行： locale-gen -en_US:en 注销或重启后，即可恢复为英文的语言环境。改为中文: 1、修改／etc/default/locale 如不存在则新建一个如下： LANG='en_US' #中文可以用 zh_CN LANGUAGE='en_US:en' #中文可以用 zh_CN:zh 2、reboot 即可 locale 命令可以列出当前系统所用的所有语言设置 Sudo apt install Sudo apt install sudo apt apt 1.4 (amd64) 用法： apt [选项] 命令 命令行软件包管理器 apt 提供软件包搜索，管理和信息查询等功能。它提供的功能与其他 APT 工具相同（像 apt-get 和 apt-cache），但是默认情况下被设置得更适合交互。 常用命令： list - 根据名称列出软件包 search - 搜索软件包描述 show - 显示软件包细节 install - 安装软件包 remove - 移除软件包 autoremove - 卸载所有自动安装且不再使用的软件包 update - 更新可用软件包列表 upgrade - 通过 安装/升级 软件来更新系统 full-upgrade - 通过 卸载/安装/升级 来更新系统 edit-sources - 编辑软件源信息文件 参见 apt(8) 以获取更多关于可用命令的信息。程序配置选项及语法都已经在 apt.conf(5) 中阐明。欲知如何配置软件源，请参阅 sources.list(5)。软件包及其版本偏好可以通过 apt_preferences(5) 来设置。关于安全方面的细节可以参考 apt-secure(8). 本 APT 具有超级牛力。 好玩的软件 oneko,cmatrix, 软件安装, gdebi ,gedit ,cinnamon ,mate,xfce,unity,gnome-fontviewer,或者 font-manager,gnome-ternimal,firefox,screefetch,file-roller(压缩包管理器),tree,transmission(迅雷),gnome-software 软件更新器,gnome-packagekit 软件包 unbuntu-desktop, Software-properties-gtk(软件源,ppa 更新) Gnome-software (软件商店) Gnome-systemmoniter(任务管理器) FTP/SFTP 客户端: 声音视频:audacity,vlc,rhythmbox 图像处理:gimp 抓图工具:shutter gnome-web-photo Mypaint,darktable,inkscape,dia,shotwell, 录屏工具:gek-recordmydesktop 视频后期处理:openshot 搜狗输入法安装,安装 gdebi 进入搜狗输入法目录输入命令行: sudo gdebi sogoupinyin_2.1.0.0086_amd64.deb 安装 cinnamon :sudo apt install cinnamon 然后运行cinnamon –replace 运行图形化命令,gksu Filezilla:sudo aptitude install –y filezilla 安装主题: elementary os 的主题 sudo add-apt-repository ppa:elementary-os/daily sudo apt-get update sudo apt-get install elementary-icon-theme ubuntukylin ukui 主题, www.ukui.org 官网教程安装这个就好 zorinos 主题安装方法，首先打开终端输入以下命令安装主题： sudo add-apt-repository ppa:noobslab/themes sudo apt-get update sudo apt-get install zorinos-themes 在终端输入以下命令安装图标主题： sudo add-apt-repository ppa:noobslab/icons2 sudo apt-get update sudo apt-get install zorinos-icons 安装或使用调节工具：如 Unity Tweak Tool、Gnome-tweak-tool 或者 Ubuntu-Tweak 来启用主题和图标。 第二章 linux 的文件系统 Lib 各种动态链接库存放的位置,类似 windows 的 dll 文件,只不过 linux 的是.so 文件, ``` ``` ","link":"https://copyer98.github.io/post/linux基本知识/"},{"title":"linux桌面环境","content":"linux 桌面环境 标签： linux 使用 ubuntu 和她的衍生 首先，ubuntu server 版本的安装这里就不再赘述，基本的还是三个步骤，首先是下载镜像，然后使用 ultraISO 刻录至 u 盘，最后通过 U 盘引导进行安装。安装过程中，会要求你输入用户名和密码，一定要牢记，因为后续软件的安装都需要密码。 然后，login 进入系统之后，开始进行用户界面的安装。首先输入如下命令： sudo apt-get install xinit 上述安装完毕之后，再安装环境管理器。本人亲测安装的是 GNOME。使用如下命令安装： sudo apt-get install gdm 然后，安装桌面环境。本人亲测安装的是 KUbuntu。安装命令如下： sudo apt-get install kubuntu-desktop centos 1、首先安装X(X Window System),命令为 yum groupinstall &quot;X Window System&quot; 回车（注意有引号） 2、由于这个软件组比较大，安装过程会比较慢，安装完成会出现complete！ 3、检查一下我们已经安装的软件以及可以安装的软件，用命令 yum grouplist 回车 4、然后安装我们需要的图形界面软件，GNOME(GNOME Desktop) 这里需要特别注意！！！！ 一定要注意 名称必须对应 不同版本的centOS的软件名可能不同 其他Linux系统类似 否则会出现No packages in any requested group available to install or update 的错误。 5、同样的。 由于这个软件组比第一个要大很多（包含700个左右的软件），安装过程会很慢，请耐心等待。安装完成会出现complete！ 6、安装完成后我们可以通过命令 startx 进入图形界面，第一次进入会比较慢，请耐心等待。（可能需要重启，命令为reboot） 如果启动正常的话，到这里就可以不用继续向下看了，如果出现问题，那么请继续看。 ","link":"https://copyer98.github.io/post/linux安装桌面环境/"},{"title":"node配置","content":"标签： 插件 淘宝 npm 地址：http://npm.taobao.org/ 如何使用 有很多方法来配置 npm 的 registry 地址，下面根据不同情境列出几种比较常用的方法 。以淘宝 npm 镜像举例： 1. 临时使用 npm --registry https://registry.npm.taobao.org install express 2. 持久使用 npm config set registry https://registry.npm.taobao.org 配置后可通过下面方式来验证是否成功 npm config get registry npm info express 3. 通过 cnpm 使用 npm install -g cnpm --registry=https://registry.npm.taobao.org 使用 cnpm install express 首先打开命令行终端 , 然后输入 npm config ls 这时你应该可以看到一个 prefix 属性 , 它表明了 npm 包的默认安装位置 , 因此可以通 过改这个配置修改包安装位置 . 具体的命令如下 : npm config set prefix &quot;your node_global path&quot; 把引号内的内容改为你所希望的路径即可 . 比如我 : npm config ls; npm config set prefix &quot;D:\\configuration\\nodeconfig\\npm&quot; npm config set cache &quot;D:\\configuration\\nodeconfig\\npm-cache&quot; ","link":"https://copyer98.github.io/post/node设置/"}]}